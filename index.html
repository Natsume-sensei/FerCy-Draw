<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FerCy Draw - Alpha Edition</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --primary: #00e5ff;
            --accent: #7000ff;
            --bg-dark: #121212;
            --panel-bg: #1e1e1e;
            --header-bg: #252525;
            --text-main: #e0e0e0;
            --text-muted: #aaaaaa;
            --border: 1px solid #333;
            --active-item: #333;
            --canvas-shadow: 0 0 30px rgba(0,0,0,0.5);
            --rec-color: #ff4444;
            --selection-border: 1px dashed #fff;
            --ruler-bg: #2a2a2a;
            --ruler-text: #888;
            --anim-timeline-bg: #1a1a1a;
            --anim-track-bg: #2d2d2d;
            --keyframe-color: #ffd700;
        }

        [data-theme="light"] {
            --primary: #007bff;
            --accent: #6610f2;
            --bg-dark: #e9ecef;
            --panel-bg: #ffffff;
            --header-bg: #f8f9fa;
            --text-main: #212529;
            --text-muted: #6c757d;
            --border: 1px solid #dee2e6;
            --active-item: #e2e6ea;
            --canvas-shadow: 0 0 20px rgba(0,0,0,0.1);
            --selection-border: 1px dashed #000;
            --ruler-bg: #e0e0e0;
            --ruler-text: #444;
            --anim-timeline-bg: #f0f0f0;
            --anim-track-bg: #e0e0e0;
            --keyframe-color: #ff8c00;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
            touch-action: none; 
        }

        /* --- SPLASH SCREEN --- */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #121212; z-index: 10000;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.8s ease-out, visibility 0.8s;
        }
        .splash-content { text-align: center; animation: floatUp 1s ease-out; }
        .splash-title {
            font-size: 3.5rem; font-weight: 800; color: var(--primary);
            letter-spacing: 2px; margin-bottom: 5px;
            text-shadow: 0 0 20px rgba(0, 229, 255, 0.4);
        }
        .splash-subtitle {
            font-size: 1.2rem; color: #fff; letter-spacing: 6px;
            text-transform: uppercase; font-weight: 300; opacity: 0.8;
            margin-bottom: 40px;
        }
        .splash-loader {
            width: 200px; height: 4px; background: #333;
            border-radius: 2px; overflow: hidden; margin: 0 auto;
        }
        .splash-bar {
            width: 0%; height: 100%; background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            animation: loading 2.5s ease-in-out forwards;
        }
        @keyframes loading { 0% { width: 0%; } 50% { width: 40%; } 100% { width: 100%; } }
        @keyframes floatUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .splash-hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        /* --- HEADER --- */
        .main-header {
            height: 35px; background: var(--header-bg); border-bottom: var(--border);
            display: flex; align-items: center; padding: 0 10px; font-size: 0.85rem; z-index: 20;
        }
        .brand { font-weight: bold; color: var(--primary); margin-right: 20px; letter-spacing: 1px; }
        .menu-item { padding: 5px 10px; cursor: pointer; color: var(--text-muted); border-radius: 4px; transition: 0.2s;}
        .menu-item:hover { color: var(--text-main); background: rgba(255,255,255,0.05); }
        .rec-btn { color: var(--text-muted); display:flex; align-items:center; gap:5px; }
        .rec-btn.recording { color: var(--rec-color); animation: pulse 1.5s infinite; font-weight: bold; }
        .rec-dot { width: 8px; height: 8px; background: currentColor; border-radius: 50%; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* --- OPTIONS BAR --- */
        .options-bar {
            height: 45px; background: var(--panel-bg); border-bottom: var(--border);
            display: flex; align-items: center; padding: 0 15px; gap: 15px; z-index: 20;
        }
        .zoom-controls {
            display: flex; align-items: center; gap: 5px;
            background: rgba(255,255,255,0.05); padding: 3px 8px; border-radius: 4px; border: 1px solid var(--border);
        }
        .zoom-btn { background: none; border: none; color: var(--text-main); cursor: pointer; font-weight: bold; width: 20px; }
        .zoom-btn:hover { color: var(--primary); }
        .zoom-display { font-size: 0.8rem; min-width: 40px; text-align: center; }
        .toggle-opt { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; cursor: pointer; }
        .toggle-opt input { accent-color: var(--primary); width: auto; height: auto; }
        select.opt-select {
            background: var(--bg-dark); color: var(--text-main); border: 1px solid var(--border);
            padding: 2px 5px; border-radius: 4px; font-size: 0.8rem; outline: none; min-width: 150px; 
        }

        /* --- WORKSPACE & RULERS --- */
        .workspace { display: flex; flex: 1; overflow: hidden; position: relative; }

        .ruler-corner {
            position: absolute; top: 0; left: 50px; width: 20px; height: 20px;
            background: var(--ruler-bg); border-right: 1px solid var(--border); border-bottom: 1px solid var(--border); z-index: 15;
        }
        .ruler-top {
            position: absolute; top: 0; left: 70px; right: 280px; height: 20px;
            background: var(--ruler-bg); border-bottom: 1px solid var(--border); overflow: hidden; z-index: 15;
        }
        /* UPDATED LAYOUT: BOTTOM 0 DEFAULT */
        .ruler-left {
            position: absolute; top: 20px; left: 50px; bottom: 0px; 
            width: 20px;
            background: var(--ruler-bg); border-right: 1px solid var(--border); overflow: hidden; z-index: 15;
            transition: bottom 0.3s ease;
        }
        .ruler-canvas { display: block; }

        .tools-panel {
            width: 50px; background: var(--panel-bg); border-right: var(--border);
            display: flex; flex-direction: column; align-items: center; padding: 30px 0 10px 0; gap: 5px; z-index: 20;
            padding-bottom: 10px; /* UPDATED LAYOUT */
            transition: padding-bottom 0.3s ease;
        }
        
        .tool-btn {
            width: 36px; height: 36px; border: none; background: transparent; color: var(--text-muted);
            border-radius: 4px; cursor: pointer; font-size: 1.2rem;
            display: flex; justify-content: center; align-items: center; transition: 0.2s; position: relative;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.1); color: var(--primary); }
        .tool-btn.active { background: var(--active-item); color: var(--primary); border-left: 3px solid var(--primary); }
        .shortcut-hint { position: absolute; bottom: 1px; right: 2px; font-size: 0.5rem; opacity: 0.5; }
        .separator { width: 80%; height: 1px; background: var(--border); margin: 5px 0; }

        /* --- CANVAS --- */
        /* UPDATED LAYOUT: BOTTOM 0 DEFAULT */
        .viewport {
            position: absolute; top: 20px; left: 70px; right: 280px; bottom: 0px;
            background: var(--bg-dark); overflow: hidden; cursor: default; touch-action: none; z-index: 5;
            transition: bottom 0.3s ease;
        }
        .viewport-bg {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background-image: radial-gradient(var(--text-muted) 1px, transparent 1px);
            background-size: 20px 20px; opacity: 0.2; pointer-events: none;
        }
        #canvas-wrapper {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; box-shadow: var(--canvas-shadow); cursor: crosshair;
            transform-origin: center center; touch-action: none; 
        }
        .drawing-canvas {
            position: absolute; top: 0; left: 0; pointer-events: none;
            transition: opacity 0.1s ease;
            transform-origin: center center;
        }
        #selection-box {
            position: absolute; border: 2px dashed #00e5ff; background: rgba(0, 229, 255, 0.1);
            pointer-events: none; display: none; z-index: 999;
        }
        #motion-path-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 900;
        }
        .motion-path-line { stroke: var(--primary); stroke-width: 2; fill: none; stroke-dasharray: 5,5; }

        /* Guides & Symmetry */
        #guides-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 998; display: none;
        }
        .guide-grid {
            width: 100%; height: 100%;
            background-image: linear-gradient(rgba(0, 255, 255, 0.3) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 255, 0.3) 1px, transparent 1px);
            background-size: 50px 50px;
        }
        .guide-line-center { position: absolute; background: cyan; opacity: 0.6; }

        #symmetry-lines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 998; display: none;
        }
        .sym-line { position: absolute; background: var(--accent); opacity: 0.8; box-shadow: 0 0 5px var(--accent); }

        /* --- RIGHT SIDEBAR --- */
        .sidebar-right {
            position: absolute; top: 0; right: 0; bottom: 0;
            width: 280px; background: var(--panel-bg); border-left: var(--border);
            display: flex; flex-direction: column; z-index: 20; overflow-y: auto;
        }

        .panel-section { padding: 15px; border-bottom: var(--border); }
        .section-title {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--text-muted); margin-bottom: 10px; font-weight: bold;
        }

        input[type="range"] { width: 100%; accent-color: var(--primary); height: 4px; background: #444; border-radius: 2px; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--primary); border-radius: 50%; cursor: pointer; }
        
        .color-well {
            width: 100%; height: 35px; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; position: relative;
        }
        input[type="color"] { width: 150%; height: 150%; position: absolute; top: -10px; left: -10px; cursor: pointer; border: none; }

        .layer-controls { padding: 10px 15px; border-bottom: var(--border); font-size: 0.85rem; }
        
        .blend-select {
            width: 100%; padding: 5px; background: var(--bg-dark); color: var(--text-main);
            border: 1px solid var(--border); border-radius: 4px; margin-bottom: 10px; font-size: 0.8rem;
        }

        .layers-list {
            flex: 1; overflow-y: auto; background: rgba(0,0,0,0.1); display: flex; flex-direction: column-reverse; min-height: 150px;
        }
        .layer-item {
            display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; font-size: 0.85rem;
        }
        .layer-item:hover { background: rgba(255,255,255,0.05); }
        .layer-item.active { background: var(--active-item); border-left: 3px solid var(--primary); }
        .vis-icon { width: 20px; text-align: center; color: var(--text-muted); margin-right: 8px; }
        .vis-icon:hover { color: #fff; }
        .layer-name { flex: 1; }
        .layer-mode-tag { font-size: 0.6rem; padding: 2px 4px; background: rgba(0,0,0,0.3); border-radius: 3px; margin-left: 5px; color: var(--primary); }
        
        .lock-icon { width: 20px; text-align: center; color: var(--text-muted); margin-left: 5px; transition:0.2s; }
        .lock-icon:hover, .lock-icon.locked { color: var(--primary); }

        .manga-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .manga-btn {
            padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            color: var(--text-muted); font-size: 0.8rem; cursor: pointer; border-radius: 4px;
        }
        .manga-btn:hover { background: var(--primary); color: #000; }

        /* Filter Buttons Grid */
        .filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .filter-btn {
            padding: 8px; background: var(--bg-dark); border: 1px solid var(--border);
            color: var(--text-main); font-size: 0.75rem; cursor: pointer; border-radius: 4px;
        }
        .filter-btn:hover { border-color: var(--primary); color: var(--primary); }

        /* --- ANIMATION TIMELINE PANEL --- */
        .timeline-panel {
            position: absolute; bottom: 0; left: 50px; right: 280px; height: 150px;
            background: var(--anim-timeline-bg); border-top: var(--border); z-index: 25;
            display: flex; flex-direction: column;
            transition: height 0.3s ease;
        }
        .timeline-controls {
            height: 35px; background: var(--panel-bg); border-bottom: 1px solid #333;
            display: flex; align-items: center; padding: 0 10px; gap: 10px;
        }
        .t-btn { background: none; border: none; color: var(--text-main); cursor: pointer; font-size: 1rem; width: 30px;}
        .t-btn:hover { color: var(--primary); }
        .time-display { font-family: monospace; font-size: 0.85rem; color: var(--primary); min-width: 60px; }
        
        .timeline-tracks { flex: 1; overflow-y: auto; overflow-x: hidden; position: relative; padding: 5px; }
        .track-header { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 5px; display:flex; justify-content:space-between; }
        .track-container { position: relative; height: 20px; background: var(--anim-track-bg); border-radius: 4px; margin-bottom: 2px; }
        .scrub-head {
            position: absolute; top: 0; left: 0; width: 2px; height: 100%; background: #ff0000; z-index: 10;
            pointer-events: none;
        }
        .keyframe-marker {
            position: absolute; top: 3px; width: 14px; height: 14px; background: var(--keyframe-color);
            border-radius: 50%; transform: translateX(-50%); border: 2px solid #fff; cursor: pointer;
        }
        .tab-bar { display: flex; border-bottom: var(--border); }
        .tab-btn { flex:1; padding:10px; text-align:center; cursor:pointer; font-size:0.8rem; background:transparent; border:none; color:var(--text-muted); }
        .tab-btn.active { color:var(--primary); border-bottom: 2px solid var(--primary); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 10001; 
            display: flex; justify-content: center; align-items: center;
            visibility: hidden; opacity: 0; transition: 0.3s;
        }
        .modal-overlay.open { visibility: visible; opacity: 1; }
        .modal-box {
            background: var(--panel-bg); padding: 25px; border-radius: 8px;
            width: 350px; border: 1px solid var(--primary);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .modal-box h2 { color: var(--primary); margin-bottom: 20px; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
        .input-group input { 
            width: 100%; padding: 8px; background: var(--bg-dark); 
            border: 1px solid var(--border); color: var(--text-main); border-radius: 4px;
        }
        .btn-main {
            width: 100%; padding: 10px; background: var(--primary); color: #000;
            border: none; border-radius: 4px; font-weight: bold; cursor: pointer;
        }
        /* SHORTCUT TABLE */
        .shortcut-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .shortcut-table td { padding: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .shortcut-key { font-weight: bold; color: var(--primary); background: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 3px; }

        .viewport.hand-active #canvas-wrapper { cursor: grab; }
        .viewport.hand-active.panning #canvas-wrapper { cursor: grabbing; }
        .hidden { display: none !important; }
        .row { display: flex; justify-content: space-between; margin-bottom: 5px;}
        
        #autosave-status {
            font-size: 0.7rem; color: var(--text-muted); margin-left: 10px; opacity: 0; transition: opacity 0.5s;
        }
        #autosave-status.visible { opacity: 1; }
    </style>
</head>
<body>

    <div id="splash-screen">
        <div class="splash-content">
            <div class="splash-title">FerCy Draw</div>
            <div class="splash-subtitle">Alpha Edition</div>
            <div class="splash-loader">
                <div class="splash-bar"></div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="new-modal">
        <div class="modal-box">
            <h2>New Project</h2>
            <div class="input-group">
                <label>Width (px)</label>
                <input type="number" id="canvas-w" value="1280">
            </div>
            <div class="input-group">
                <label>Height (px)</label>
                <input type="number" id="canvas-h" value="720">
            </div>
            <button class="btn-main" onclick="initCanvas()">Create Canvas</button>
            <button class="btn-main" onclick="restoreSession()" style="margin-top:10px; background:#444; color:#fff;">Restore Last Session</button>
        </div>
    </div>

    <div class="modal-overlay" id="shortcuts-modal" onclick="if(event.target===this) this.classList.remove('open')">
        <div class="modal-box" style="width: 500px; max-height: 80vh; overflow-y: auto;">
            <h2>Keyboard Shortcuts</h2>
            <table class="shortcut-table">
                <tr><td><span class="shortcut-key">B</span></td><td>Pencil / Brush Tool</td></tr>
                <tr><td><span class="shortcut-key">E</span></td><td>Eraser Tool</td></tr>
                <tr><td><span class="shortcut-key">V</span></td><td>Move Tool</td></tr>
                <tr><td><span class="shortcut-key">M</span></td><td>Selection Tool</td></tr>
                <tr><td><span class="shortcut-key">Alt</span> / <span class="shortcut-key">I</span></td><td>Eyedropper</td></tr>
                <tr><td><span class="shortcut-key">Space</span></td><td>Hand Tool (Pan)</td></tr>
                <tr><td><span class="shortcut-key">F</span></td><td>Fill Tool</td></tr>
                <tr><td><span class="shortcut-key">R</span></td><td>Rectangle</td></tr>
                <tr><td><span class="shortcut-key">C</span></td><td>Circle</td></tr>
                <tr><td><span class="shortcut-key">T</span></td><td>Triangle</td></tr>
                <tr><td><span class="shortcut-key">P</span></td><td>Motion Path Tool</td></tr>
                <tr><td><span class="shortcut-key">[</span> / <span class="shortcut-key">]</span></td><td>Decrease / Increase Brush Size</td></tr>
                <tr><td><span class="shortcut-key">Ctrl + Z</span></td><td>Undo</td></tr>
                <tr><td><span class="shortcut-key">Shift + N</span></td><td>New Layer</td></tr>
                <tr><td><span class="shortcut-key">Delete</span></td><td>Delete Active Layer</td></tr>
                <tr><td><span class="shortcut-key">Enter</span></td><td>Play / Pause Animation</td></tr>
            </table>
            <button class="btn-main" onclick="document.getElementById('shortcuts-modal').classList.remove('open')" style="margin-top:20px;">Close</button>
        </div>
    </div>

    <input type="file" id="upload-input" style="display:none" accept="image/*" onchange="processUpload(this)">

    <header class="main-header">
        <div class="brand">FerCy Draw Alpha Edition</div>
        <div class="menu-item" onclick="document.getElementById('new-modal').classList.add('open')">File</div>
        <div class="menu-item" onclick="toggleRulers()">View: Rulers</div>
        <div class="menu-item" onclick="toggleGuides()">View: Guides</div>
        <div class="menu-item" onclick="triggerUpload()">Import</div>
        <div class="menu-item" onclick="exportImage()">Export</div>
        <div class="menu-item" onclick="toggleTheme()">Theme</div>
        <div class="menu-item" onclick="document.getElementById('shortcuts-modal').classList.add('open')">Help (?)</div>
        <div class="menu-item" onclick="toggleAnimationPanel()" style="color:var(--primary); border:1px solid var(--primary);">üé¨ Animator</div>
        <div class="menu-item rec-btn" id="rec-btn" onclick="toggleRecord()">
            <div class="rec-dot"></div> <span id="rec-text">Record</span>
        </div>
        <div id="autosave-status">Saving...</div>
        <div style="flex:1"></div>
        <div class="menu-item" style="font-size:0.7rem; opacity:0.7;">v1.0</div>
    </header>

    <div class="options-bar">
        <div style="font-size:0.85rem; font-weight:bold; width: 80px;" id="tool-name-display">Tool: Pencil</div>
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
            <span class="zoom-display" id="zoom-text">100%</span>
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="resetZoom()" style="font-size:0.7rem; width:auto; margin-left:5px;">R</button>
        </div>
        <div style="width:1px; height:20px; background:var(--border)"></div>
        
        <label class="toggle-opt">
            <input type="checkbox" id="pressure-chk" checked> Pressure
        </label>

        <div style="width:1px; height:20px; background:var(--border)"></div>
        
        <div style="display:flex; align-items:center; gap:5px; width: 120px;">
            <span style="font-size:0.8rem">Stab: <span id="stab-val">0</span></span>
            <input type="range" id="stab-slider" min="0" max="10" value="0" oninput="syncSettings('stabilizer', this.value)">
        </div>

        <div style="width:1px; height:20px; background:var(--border)"></div>

        <div style="display:flex; align-items:center; gap:10px; width: 130px;">
            <span style="font-size:0.8rem">Size: <span id="opt-size-val">5</span></span>
            <input type="range" id="opt-size" min="1" max="100" value="5" oninput="syncSettings('size', this.value)">
        </div>
        <div style="width:1px; height:20px; background:var(--border)"></div>
        
        <select class="opt-select" id="tool-type-select" onchange="syncSettings('type', this.value)">
        </select>

        <div style="flex:1"></div>
        <button onclick="layerUndo()" style="background:none; border:1px solid var(--border); color:var(--text-main); padding:4px 10px; border-radius:4px; cursor:pointer;">‚Ü© Undo</button>
    </div>

    <div class="ruler-corner"></div>
    <div class="ruler-top" id="ruler-top-container"><canvas id="ruler-top-canvas" class="ruler-canvas"></canvas></div>
    <div class="ruler-left" id="ruler-left-container"><canvas id="ruler-left-canvas" class="ruler-canvas"></canvas></div>

    <div class="workspace">
        <div class="tools-panel">
            <button class="tool-btn active" onclick="setTool('pencil')" title="Pencil/Brush (B)">üñå<span class="shortcut-hint">B</span></button>
            <button class="tool-btn" onclick="setTool('eraser')" title="Eraser (E)">‚å´<span class="shortcut-hint">E</span></button>
            
            <div class="separator"></div>
            
            <button class="tool-btn" onclick="setTool('hand')" title="Hand Tool (Space)">‚úã</button>
            <button class="tool-btn" onclick="setTool('move')" title="Move Layer (V)">‚¨ç<span class="shortcut-hint">V</span></button>
            <button class="tool-btn" onclick="setTool('select')" title="Selection (M)">‚õ∂<span class="shortcut-hint">M</span></button>
            <button class="tool-btn" onclick="setTool('eyedropper')" title="Eyedropper (Alt/I)">üíâ<span class="shortcut-hint">Alt</span></button>
            
            <div class="separator"></div>
            
            <button class="tool-btn" onclick="setTool('fill')" title="Flood Fill (F)">üíß</button>
            <button class="tool-btn" onclick="setTool('rect')" title="Rectangle (R)">‚¨ú</button>
            <button class="tool-btn" onclick="setTool('circle')" title="Circle (C)">‚óØ</button>
            <button class="tool-btn" onclick="setTool('triangle')" title="Triangle (T)">‚ñ≥</button>
            
            <div class="separator"></div>
            <button class="tool-btn" onclick="setTool('motionpath')" title="Draw Motion Path (P)" style="color:var(--keyframe-color)">„Ä∞</button>
        </div>

        <div class="viewport" id="viewport">
            <div class="viewport-bg"></div>
            <div id="canvas-wrapper">
                <svg id="motion-path-svg"></svg>
                <div id="selection-box"></div>
                <div id="guides-overlay">
                    <div class="guide-grid"></div>
                    <div class="guide-line-center" style="top:50%; left:0; width:100%; height:1px;"></div>
                    <div class="guide-line-center" style="top:0; left:50%; width:1px; height:100%;"></div>
                </div>
                <div id="symmetry-lines">
                    <div class="sym-line" id="sym-v" style="display:none; top:0; left:50%; width:1px; height:100%;"></div>
                    <div class="sym-line" id="sym-h" style="display:none; top:50%; left:0; width:100%; height:1px;"></div>
                </div>
            </div>
        </div>

        <div class="timeline-panel" id="timeline-panel" style="display:none;">
            <div class="timeline-controls">
                <button class="t-btn" id="play-pause-btn" onclick="togglePlayAnim()" title="Play/Pause (Enter)">‚ñ∂</button>
                <button class="t-btn" onclick="stopAnim()" title="Stop">‚èπ</button>
                <div class="time-display" id="time-display">00:00</div>
                <input type="range" id="time-scrubber" min="0" max="100" value="0" step="1" style="width:300px;" oninput="scrubTime(this.value)">
                <div style="flex:1"></div>
                <button class="t-btn" style="width:auto; font-size:0.8rem; padding:0 10px;" onclick="addKeyframe()" title="Add Keyframe">‚ûï Keyframe</button>
            </div>
            <div class="timeline-tracks" id="timeline-tracks">
            </div>
        </div>

        <div class="sidebar-right">
            <div class="tab-bar">
                <button class="tab-btn active" onclick="switchTab('design')">Design</button>
                <button class="tab-btn" onclick="switchTab('anim')">Animation</button>
            </div>

            <div id="tab-design" class="tab-content active">
                <div class="panel-section">
                    <div class="section-title">Symmetry Ruler</div>
                    <select class="blend-select" onchange="setSymmetry(this.value)">
                        <option value="none">Off</option>
                        <option value="vertical">Vertical (Mirror)</option>
                        <option value="horizontal">Horizontal (Mirror)</option>
                        <option value="quad">Dual Axis (Quad)</option>
                        <option value="radial">Radial (Kaleidoscope)</option>
                    </select>
                </div>

                <div class="panel-section">
                    <div class="section-title">Color & Shapes</div>
                    <div class="color-well">
                        <input type="color" id="main-color" value="#000000" onchange="syncSettings('color', this.value)">
                    </div>
                    <div style="margin-top:10px;">
                        <label style="display:flex; align-items:center; gap:8px; font-size:0.85rem; cursor:pointer;">
                            <input type="checkbox" id="fill-shape-chk"> Fill Shapes (2D)
                        </label>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">Filters (Active Layer)</div>
                    <div class="filter-grid">
                        <button class="filter-btn" onclick="applyFilter('blur')">Blur 5px</button>
                        <button class="filter-btn" onclick="applyFilter('grayscale')">Grayscale</button>
                        <button class="filter-btn" onclick="applyFilter('invert')">Invert</button>
                        <button class="filter-btn" onclick="applyFilter('brightness')">Brighten</button>
                    </div>
                </div>

                <div class="panel-section">
                    <div class="section-title">Manga Templates</div>
                    <div class="manga-grid">
                        <button class="manga-btn" onclick="applyTemplate('4koma')">4-Koma</button>
                        <button class="manga-btn" onclick="applyTemplate('standard')">Standard</button>
                        <button class="manga-btn" onclick="applyTemplate('action')">Action</button>
                        <button class="manga-btn" onclick="applyTemplate('dialog')">Dialog</button>
                    </div>
                </div>
            </div>

            <div id="tab-anim" class="tab-content">
                <div class="panel-section">
                    <div class="section-title">Animation Preset (Entrance)</div>
                    <div class="filter-grid">
                        <button class="filter-btn" onclick="applyAnimPreset('fadein')">Fade In</button>
                        <button class="filter-btn" onclick="applyAnimPreset('zoom')">Zoom In</button>
                        <button class="filter-btn" onclick="applyAnimPreset('slideleft')">Slide Left</button>
                        <button class="filter-btn" onclick="applyAnimPreset('pop')">Pop</button>
                        <button class="filter-btn" onclick="applyAnimPreset('spin')">Spin</button>
                    </div>
                </div>
                <div class="panel-section">
                    <div class="section-title">Timing & Motion</div>
                    <div class="input-group">
                        <label>Duration (frames)</label>
                        <input type="number" id="anim-duration" value="60" min="10">
                    </div>
                    <div class="input-group">
                        <label>Delay (frames)</label>
                        <input type="number" id="anim-delay" value="0" min="0">
                    </div>
                    <button class="btn-main" onclick="clearLayerAnim()" style="background:#d32f2f; margin-top:5px;">Clear Animation</button>
                    <button class="btn-main" onclick="applyAIMagic()" style="background:linear-gradient(45deg, #7000ff, #00e5ff); margin-top:10px; color:#fff;">‚ú® Magic AI Animate</button>
                </div>
                <div class="panel-section">
                    <div class="section-title">Motion Path</div>
                    <p style="font-size:0.7rem; color:var(--text-muted);">Use the Motion Path tool („Ä∞) to draw a custom path for the active layer.</p>
                </div>
            </div>

            <div class="panel-section" style="padding: 10px; display:flex; gap:5px;">
                <button class="btn-main" onclick="addLayer()" style="font-size:0.8rem;">+ New Layer</button>
                <button class="btn-main" onclick="deleteLayer()" style="background:#d32f2f; width:40px;">üóë</button>
            </div>

            <div class="layer-controls">
                <div class="row">
                    <span>Blend Mode:</span>
                </div>
                <select class="blend-select" id="blend-mode-select" onchange="updateLayerBlendMode(this.value)">
                    <option value="normal">Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                </select>

                <div class="row">
                    <span>Layer Opacity: <span id="layer-op-val">100</span>%</span>
                </div>
                <input type="range" id="layer-op-slider" min="0" max="100" value="100" oninput="updateLayerOpacity(this.value)">
                
                <div style="margin-top:15px; border-top:1px solid var(--border); padding-top:10px;">
                    <label style="display:flex; align-items:center; gap:8px; font-size:0.85rem; cursor:pointer;">
                         <input type="checkbox" id="alpha-lock-chk" onchange="toggleAlphaLock(this.checked)"> 
                         üîí Alpha Lock (Shading)
                    </label>
                </div>
            </div>

            <div class="layers-list" id="layers-container"></div>
        </div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        let config = { width: 1280, height: 720, zoom: 1.0, panX: 0, panY: 0 };
        let tools = { 
            current: 'pencil', 
            size: 5, 
            eraserSize: 20, 
            opacity: 1.0, 
            color: '#000000',
            stabilizer: 0,
            brushType: 'pencil-HB', 
            eraserType: 'hard',
            symmetry: 'none',
            roughness: 0,
            blending: false
        };
        let layers = [];
        let activeLayerId = null;
        let layerCounter = 0;

        // --- ANIMATION STATE ---
        let animState = {
            isPlaying: false,
            currentFrame: 0,
            totalFrames: 100, 
            fps: 60,
            reqId: null
        };

        const brushLibrary = {
            pencil: [
                { id: 'pencil-H', name: 'Pencil (H) - Hard', type: 'round', opacity: 0.6, blur: 0, rough: 0.1 },
                { id: 'pencil-HB', name: 'Pencil (HB) - Standard', type: 'round', opacity: 0.8, blur: 0.5, rough: 0.2 },
                { id: 'pencil-2B', name: 'Pencil (2B) - Soft', type: 'round', opacity: 1.0, blur: 1, rough: 0.3 },
                { id: 'pencil-6B', name: 'Pencil (6B) - Very Soft', type: 'round', opacity: 1.0, blur: 2, rough: 0.4 },
                { id: 'mechanical', name: 'Mechanical Pencil', type: 'square', opacity: 0.9, blur: 0, rough: 0 },
                { id: 'charcoal', name: 'Charcoal (Arang)', type: 'round', opacity: 1.0, blur: 4, rough: 1.5 },
                { id: 'conte', name: 'Conte / Pastel', type: 'round', opacity: 0.8, blur: 3, rough: 0.8 }
            ],
            brush: [
                { id: 'oil', name: 'Oil Brush', type: 'round', opacity: 1.0, blur: 0.5, rough: 0 },
                { id: 'watercolor', name: 'Watercolor', type: 'round', opacity: 0.3, blur: 4, rough: 0.1 }, 
                { id: 'gouache', name: 'Gouache / Pen', type: 'round', opacity: 1.0, blur: 0, rough: 0 },
                { id: 'flat', name: 'Flat Brush', type: 'square', opacity: 1.0, blur: 0, rough: 0 },
                { id: 'round', name: 'Round Brush', type: 'round', opacity: 0.9, blur: 1, rough: 0 },
                { id: 'fan', name: 'Fan Brush', type: 'round', opacity: 0.7, blur: 1, rough: 0.6 },
                { id: 'detail', name: 'Detail Brush', type: 'round', opacity: 1.0, blur: 0, rough: 0 }
            ],
            eraser: [
                { id: 'hard', name: 'Hard Eraser' },
                { id: 'soft', name: 'Soft Eraser (Blur)' }
            ]
        };

        let isDrawing = false;
        let isPanning = false;
        let startPanX, startPanY; 
        
        let points = []; 
        let moveStart = { x: 0, y: 0 };
        let moveSnapshot = null;
        
        let selection = null; 
        let isSelecting = false;
        let selStart = { x:0, y:0 };
        let motionPathPoints = []; 

        let snapshot; 
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        let isSpaceDown = false;
        let isAltDown = false; 
        let previousTool = 'pencil';
        
        let mouseX = 0, mouseY = 0;
        let lastX = 0, lastY = 0;

        let rulersVisible = true;
        let guidesVisible = false;
        let autosaveInterval = null;

        // --- INIT ---
        window.addEventListener('load', () => {
            setTimeout(() => {
                const splash = document.getElementById('splash-screen');
                splash.classList.add('splash-hidden');
                document.getElementById('new-modal').classList.add('open');
                setTimeout(() => splash.remove(), 800);
            }, 2500);
            resizeRulers(); 
        });
        
        window.addEventListener('resize', resizeRulers);

        function initCanvas() {
            if (autosaveInterval) clearInterval(autosaveInterval);

            const w = parseInt(document.getElementById('canvas-w').value);
            const h = parseInt(document.getElementById('canvas-h').value);
            config.width = w; config.height = h;

            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = w + 'px'; wrapper.style.height = h + 'px';
            
            config.zoom = 1.0; config.panX = 0; config.panY = 0;
            updateCanvasTransform(); updateZoomDisplay();

            layers = []; layerCounter = 0;
            addLayer('Background', true);
            addLayer('Layer 1');

            document.getElementById('new-modal').classList.remove('open');
            updateToolOptionsUI();
            
            if(guidesVisible) document.getElementById('guides-overlay').style.display = 'block';
            setSymmetry(tools.symmetry);

            startAutosave();
        }

        // --- RULERS ---
        function resizeRulers() {
            const topC = document.getElementById('ruler-top-canvas');
            const leftC = document.getElementById('ruler-left-canvas');
            const topDiv = document.getElementById('ruler-top-container');
            const leftDiv = document.getElementById('ruler-left-container');
            if(!topC || !leftC) return;
            topC.width = topDiv.clientWidth; topC.height = topDiv.clientHeight;
            leftC.width = leftDiv.clientWidth; leftC.height = leftDiv.clientHeight;
            drawRulers();
        }

        function drawRulers() {
            if(!rulersVisible) return;
            const topC = document.getElementById('ruler-top-canvas');
            const leftC = document.getElementById('ruler-left-canvas');
            if(!topC || !leftC) return;
            const ctxT = topC.getContext('2d');
            const ctxL = leftC.getContext('2d');
            
            ctxT.clearRect(0,0,topC.width, topC.height);
            ctxL.clearRect(0,0,leftC.width, leftC.height);
            ctxT.fillStyle = '#888'; ctxT.strokeStyle = '#555'; ctxT.font = '10px Segoe UI';
            ctxL.fillStyle = '#888'; ctxL.strokeStyle = '#555'; ctxL.font = '10px Segoe UI';

            let step = 50 * config.zoom;
            if (config.zoom >= 2.0) step = 20 * config.zoom; 
            if (config.zoom <= 0.5) step = 100 * config.zoom; 
            
            const startX = (config.panX * config.zoom);
            const startY = (config.panY * config.zoom);

            for(let i = 0; i < topC.width; i+=10) {
                const h = (i % (step) < 10) ? 15 : (i % (step/2) < 10) ? 10 : 5;
                ctxT.beginPath(); ctxT.moveTo(i, 20); ctxT.lineTo(i, 20-h); ctxT.stroke();
                if (h === 15) {
                    const labelVal = Math.round((i / config.zoom) - config.panX);
                    ctxT.fillText(labelVal, i+2, 10);
                }
            }
            
            for(let i = 0; i < leftC.height; i+=10) {
                 const h = (i % (step) < 10) ? 15 : (i % (step/2) < 10) ? 10 : 5;
                ctxL.beginPath(); ctxL.moveTo(20, i); ctxL.lineTo(20-h, i); ctxL.stroke();
                 if (h === 15) {
                    const labelVal = Math.round((i / config.zoom) - config.panY);
                    ctxL.save(); ctxL.translate(10, i+2); ctxL.rotate(-Math.PI/2);
                    ctxL.fillText(labelVal, 0, 0); ctxL.restore();
                }
            }
        }

        function toggleRulers() {
            rulersVisible = !rulersVisible;
            document.querySelector('.ruler-top').style.display = rulersVisible ? 'block' : 'none';
            document.querySelector('.ruler-left').style.display = rulersVisible ? 'block' : 'none';
            document.querySelector('.ruler-corner').style.display = rulersVisible ? 'block' : 'none';
            drawRulers();
        }

        // --- LAYERS ---
        function addLayer(name = null, isBg = false) {
            layerCounter++; const id = layerCounter; const title = name || `Layer ${id}`;
            const canvas = document.createElement('canvas');
            canvas.width = config.width; canvas.height = config.height;
            canvas.className = 'drawing-canvas'; canvas.style.zIndex = id; 
            
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
            if (isBg) { ctx.fillStyle = "#ffffff"; ctx.fillRect(0,0,config.width, config.height); }
            document.getElementById('canvas-wrapper').appendChild(canvas);
            
            const layer = { 
                id, name: title, canvas, ctx, 
                visible: true, opacity: 1.0, blendMode: 'normal', alphaLock: false, 
                history: [], historyPtr: -1,
                anim: {
                    keyframes: [],
                    motionPath: [],
                    usePath: false
                }
            };
            layers.push(layer);
            saveHistory(layer);
            setActiveLayer(id);
            renderTimeline();
            return layer;
        }

        // --- ANIMATION SYSTEM ---
        function toggleAnimationPanel() {
            const panel = document.getElementById('timeline-panel');
            const isOpen = panel.style.display !== 'none';
            panel.style.display = isOpen ? 'none' : 'flex';
            
            // ADJUST WORKSPACE TO REMOVE BLACK BOX
            document.querySelector('.ruler-left').style.bottom = isOpen ? '0px' : '150px';
            document.querySelector('.tools-panel').style.paddingBottom = isOpen ? '10px' : '160px';
            document.getElementById('viewport').style.bottom = isOpen ? '0px' : '150px';
            
            resizeRulers();
            renderTimeline();
            if(!isOpen) switchTab('anim');
        }

        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector(`.tab-btn[onclick="switchTab('${tab}')"]`).classList.add('active');
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        function addKeyframe() {
            const l = layers.find(x => x.id === activeLayerId);
            if(!l) return;
            const existingIdx = l.anim.keyframes.findIndex(k => k.frame === animState.currentFrame);
            const kf = {
                frame: animState.currentFrame,
                x: 0, y: 0, scale: 1, rotation: 0, opacity: l.opacity
            };
            if(existingIdx >= 0) l.anim.keyframes[existingIdx] = kf;
            else l.anim.keyframes.push(kf);
            l.anim.keyframes.sort((a,b) => a.frame - b.frame);
            renderTimeline();
        }

        function clearLayerAnim() {
            const l = layers.find(x => x.id === activeLayerId);
            if(l) { 
                l.anim.keyframes = []; 
                l.anim.motionPath = []; 
                l.anim.usePath = false; 
                document.getElementById('motion-path-svg').innerHTML = '';
                renderTimeline(); 
            }
        }

        function applyAnimPreset(type) {
            const l = layers.find(x => x.id === activeLayerId);
            if(!l) return;
            const startFrame = parseInt(document.getElementById('anim-delay').value) || 0;
            const duration = parseInt(document.getElementById('anim-duration').value) || 60;
            const endFrame = startFrame + duration;
            l.anim.keyframes = [];
            
            if (type === 'fadein') {
                l.anim.keyframes.push({ frame: startFrame, x:0, y:0, scale:1, rotation:0, opacity:0 });
                l.anim.keyframes.push({ frame: endFrame, x:0, y:0, scale:1, rotation:0, opacity:1 });
            } else if (type === 'zoom') {
                l.anim.keyframes.push({ frame: startFrame, x:0, y:0, scale:0, rotation:0, opacity:0 });
                l.anim.keyframes.push({ frame: endFrame, x:0, y:0, scale:1, rotation:0, opacity:1 });
            } else if (type === 'slideleft') {
                l.anim.keyframes.push({ frame: startFrame, x: 200, y:0, scale:1, rotation:0, opacity:0 });
                l.anim.keyframes.push({ frame: endFrame, x:0, y:0, scale:1, rotation:0, opacity:1 });
            } else if (type === 'pop') {
                l.anim.keyframes.push({ frame: startFrame, x:0, y:0, scale:0, rotation:0, opacity:1 });
                l.anim.keyframes.push({ frame: startFrame + (duration*0.8), x:0, y:0, scale:1.2, rotation:0, opacity:1 });
                l.anim.keyframes.push({ frame: endFrame, x:0, y:0, scale:1, rotation:0, opacity:1 });
            } else if (type === 'spin') {
                 l.anim.keyframes.push({ frame: startFrame, x:0, y:0, scale:0, rotation: -360, opacity:0 });
                 l.anim.keyframes.push({ frame: endFrame, x:0, y:0, scale:1, rotation:0, opacity:1 });
            }
            renderTimeline();
        }

        function applyAIMagic() {
            const l = layers.find(x => x.id === activeLayerId);
            if(!l) return;
            l.anim.keyframes = [];
            const steps = 5;
            for(let i=0; i<=steps; i++) {
                const frame = Math.floor((100 / steps) * i);
                l.anim.keyframes.push({
                    frame: frame,
                    x: Math.random() * 200 - 100,
                    y: Math.random() * 200 - 100,
                    scale: 0.5 + Math.random(),
                    rotation: Math.random() * 360 - 180,
                    opacity: 0.5 + (Math.random() * 0.5)
                });
            }
            renderTimeline();
            alert("AI has generated a random complex animation sequence for this layer!");
        }

        function renderTimeline() {
            const trackContainer = document.getElementById('timeline-tracks');
            trackContainer.innerHTML = '';
            
            const scrubber = document.createElement('div');
            scrubber.className = 'scrub-head';
            const pct = (animState.currentFrame / 100) * 100;
            scrubber.style.left = pct + '%';
            trackContainer.appendChild(scrubber);

            layers.forEach(l => {
                const row = document.createElement('div');
                const head = document.createElement('div');
                head.className = 'track-header';
                head.innerText = l.name;
                row.appendChild(head);
                
                const track = document.createElement('div');
                track.className = 'track-container';
                
                l.anim.keyframes.forEach(k => {
                    const marker = document.createElement('div');
                    marker.className = 'keyframe-marker';
                    const kPct = (k.frame / 100) * 100;
                    marker.style.left = kPct + '%';
                    marker.onclick = () => { animState.currentFrame = k.frame; updateAnimationState(); };
                    track.appendChild(marker);
                });
                
                row.appendChild(track);
                trackContainer.appendChild(row);
            });
        }

        function scrubTime(val) {
            animState.currentFrame = parseInt(val);
            document.getElementById('time-display').innerText = `Fr:${animState.currentFrame}`;
            updateAnimationState();
            renderTimeline();
        }

        // --- UPDATED ANIMATION CONTROLS ---
        function togglePlayAnim() {
            if (animState.isPlaying) stopAnim();
            else startAnim();
        }

        function startAnim() {
            animState.isPlaying = true;
            document.getElementById('play-pause-btn').innerText = "‚è∏";
            animLoop();
        }

        function stopAnim() {
            animState.isPlaying = false;
            document.getElementById('play-pause-btn').innerText = "‚ñ∂";
            cancelAnimationFrame(animState.reqId);
        }

        function animLoop() {
            if(!animState.isPlaying) return;
            animState.currentFrame++;
            if(animState.currentFrame > 100) animState.currentFrame = 0; 
            
            document.getElementById('time-scrubber').value = animState.currentFrame;
            document.getElementById('time-display').innerText = `Fr:${animState.currentFrame}`;
            
            updateAnimationState();
            renderTimeline();
            
            setTimeout(() => {
                animState.reqId = requestAnimationFrame(animLoop);
            }, 1000 / animState.fps);
        }

        function updateAnimationState() {
            layers.forEach(l => {
                const style = l.canvas.style;
                if (l.anim.usePath && l.anim.motionPath.length > 0) {
                     const pathIdx = Math.floor((animState.currentFrame / 100) * (l.anim.motionPath.length - 1));
                     if(pathIdx >= 0 && pathIdx < l.anim.motionPath.length) {
                         const pt = l.anim.motionPath[pathIdx];
                         style.transform = `translate(${pt.x - config.width/2}px, ${pt.y - config.height/2}px)`;
                         return;
                     }
                }

                const keys = l.anim.keyframes;
                if (keys.length === 0) {
                    style.transform = 'none'; style.opacity = l.opacity;
                    return;
                }
                
                let prev = keys[0], next = keys[keys.length-1];
                if (animState.currentFrame <= keys[0].frame) { applyTransform(style, keys[0]); return; }
                if (animState.currentFrame >= keys[keys.length-1].frame) { applyTransform(style, keys[keys.length-1]); return; }

                for (let i = 0; i < keys.length - 1; i++) {
                    if (animState.currentFrame >= keys[i].frame && animState.currentFrame < keys[i+1].frame) {
                        prev = keys[i]; next = keys[i+1]; break;
                    }
                }

                const t = (animState.currentFrame - prev.frame) / (next.frame - prev.frame);
                const x = prev.x + (next.x - prev.x) * t;
                const y = prev.y + (next.y - prev.y) * t;
                const s = prev.scale + (next.scale - prev.scale) * t;
                const r = prev.rotation + (next.rotation - prev.rotation) * t;
                const o = prev.opacity + (next.opacity - prev.opacity) * t;

                style.transform = `translate(${x}px, ${y}px) scale(${s}) rotate(${r}deg)`;
                style.opacity = o;
            });
        }

        function applyTransform(style, k) {
            style.transform = `translate(${k.x}px, ${k.y}px) scale(${k.scale}) rotate(${k.rotation}deg)`;
            style.opacity = k.opacity;
        }

        // --- SHORTCUTS & INPUT ---
        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            // Existing shortcuts
            if (e.code === 'Space' && !isSpaceDown) { isSpaceDown = true; previousTool = tools.current; setTool('hand'); }
            if (e.key === 'Alt' && !isAltDown) { e.preventDefault(); isAltDown = true; document.getElementById('canvas-wrapper').style.cursor = 'copy'; }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); layerUndo(); }
            
            // NEW SHORTCUTS
            if (e.key === '?') document.getElementById('shortcuts-modal').classList.add('open');
            if (e.key === 'Escape') { 
                selection = null; document.getElementById('selection-box').style.display = 'none'; 
                document.getElementById('shortcuts-modal').classList.remove('open');
            }
            if (e.key === 'Enter') togglePlayAnim();
            if (e.key === 'Delete') deleteLayer();

            // Tool Shortcuts
            if (!e.ctrlKey && !isSpaceDown && !isAltDown) {
                const k = e.key.toLowerCase();
                if (k === 'b') setTool('pencil');
                if (k === 'e') setTool('eraser');
                if (k === 'v') setTool('move');
                if (k === 'm') setTool('select');
                if (k === 'i') setTool('eyedropper');
                if (k === 'f') setTool('fill');
                if (k === 'r') setTool('rect');
                if (k === 'c') setTool('circle');
                if (k === 't') setTool('triangle');
                if (k === 'p') setTool('motionpath');
                // Layer New
                if (k === 'n' && e.shiftKey) addLayer();
            }

            if (e.key === '[') { 
                let s = parseInt(document.getElementById('opt-size').value) - 1; 
                if(s<1) s=1; syncSettings('size', s); 
            }
            if (e.key === ']') { 
                let s = parseInt(document.getElementById('opt-size').value) + 1; 
                if(s>100) s=100; syncSettings('size', s); 
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') { isSpaceDown = false; setTool(previousTool); }
            if (e.key === 'Alt') { isAltDown = false; if(tools.current !== 'eyedropper') setTool(tools.current); }
        });

        // --- STANDARD TOOL LOGIC ---
        function setTool(name) {
            if(tools.current === 'eraser') tools.eraserSize = tools.size;
            tools.current = name;
            
            if(name === 'eraser') {
                syncSettings('size', tools.eraserSize);
                document.getElementById('tool-name-display').innerText = "Tool: Eraser";
            } else if (name === 'motionpath') {
                document.getElementById('tool-name-display').innerText = "Tool: Draw Path";
            } else {
                document.getElementById('tool-name-display').innerText = "Tool: " + name.charAt(0).toUpperCase() + name.slice(1);
            }

            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`.tool-btn[onclick="setTool('${name}')"]`);
            if(btn) btn.classList.add('active');
            
            const vp = document.getElementById('viewport');
            vp.classList.remove('hand-active');
            const wrapper = document.getElementById('canvas-wrapper');
            
            if (name === 'hand') { vp.classList.add('hand-active'); wrapper.style.cursor = 'grab'; }
            else if (name === 'move') { wrapper.style.cursor = 'move'; }
            else if (name === 'select') { wrapper.style.cursor = 'cell'; }
            else if (name === 'eyedropper') { wrapper.style.cursor = 'copy'; }
            else if (name === 'motionpath') { wrapper.style.cursor = 'crosshair'; }
            else { wrapper.style.cursor = 'crosshair'; }
            
            updateToolOptionsUI(); 
        }

        function updateToolOptionsUI() {
            const select = document.getElementById('tool-type-select');
            select.innerHTML = '';
            let options = [];
            
            if (tools.current === 'eraser') options = brushLibrary.eraser;
            else if (tools.current === 'pencil') options = brushLibrary.pencil;
            else if (['rect', 'circle', 'triangle', 'fill', 'hand', 'move', 'select', 'eyedropper', 'motionpath'].includes(tools.current)) {
                select.style.display = 'none'; return;
            } else {
                const grp1 = document.createElement('optgroup'); grp1.label = "Pencils";
                brushLibrary.pencil.forEach(o => {
                    const op = document.createElement('option'); op.value = o.id; op.innerText = o.name;
                    if(tools.brushType === o.id) op.selected = true;
                    grp1.appendChild(op);
                });
                select.appendChild(grp1);
                const grp2 = document.createElement('optgroup'); grp2.label = "Brushes";
                brushLibrary.brush.forEach(o => {
                     const op = document.createElement('option'); op.value = o.id; op.innerText = o.name;
                     if(tools.brushType === o.id) op.selected = true;
                     grp2.appendChild(op);
                });
                select.appendChild(grp2);
                select.style.display = 'block';
                return;
            }

            select.style.display = 'block';
            options.forEach(o => {
                const op = document.createElement('option');
                op.value = o.id; op.innerText = o.name;
                if(tools.current === 'eraser' && tools.eraserType === o.id) op.selected = true;
                if(tools.current !== 'eraser' && tools.brushType === o.id) op.selected = true;
                select.appendChild(op);
            });
        }

        // --- INTERACTION ---
        const wrapper = document.getElementById('canvas-wrapper');
        const viewport = document.getElementById('viewport');
        
        viewport.addEventListener('pointerdown', onMouseDown);
        window.addEventListener('pointermove', onMouseMove);
        window.addEventListener('pointerup', onMouseUp);

        function getActiveCtx() { const l = layers.find(x => x.id === activeLayerId); return (l && l.visible) ? l.ctx : null; }

        function onMouseDown(e) {
            if (e.isPrimary === false) return; 
            if (tools.current === 'hand') {
                isPanning = true; startPanX = e.clientX; startPanY = e.clientY;
                viewport.classList.add('panning'); viewport.setPointerCapture(e.pointerId); return;
            }

            const rect = wrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left) / config.zoom;
            const y = (e.clientY - rect.top) / config.zoom;
            lastX = x; lastY = y; 

            if (tools.current === 'motionpath') {
                isDrawing = true;
                motionPathPoints = [{x, y}];
                return;
            }

            if (x < 0 || y < 0 || x > config.width || y > config.height) return;
            if (tools.current === 'eyedropper' || isAltDown) { pickColor(x, y); return; }

            const ctx = getActiveCtx(); if (!ctx) return;
            const l = layers.find(x => x.id === activeLayerId);
            viewport.setPointerCapture(e.pointerId);

            if (tools.current === 'move') { isDrawing = true; moveStart = { x, y }; moveSnapshot = ctx.getImageData(0,0, config.width, config.height); return; }
            if (tools.current === 'select') { 
                isSelecting = true; selStart = { x, y }; 
                const selBox = document.getElementById('selection-box');
                selBox.style.display = 'block'; selBox.style.left = x + 'px'; selBox.style.top = y + 'px'; selBox.style.width = '0px'; selBox.style.height = '0px'; 
                return; 
            }

            isDrawing = true; ctx.save();
            if (selection) { ctx.beginPath(); ctx.rect(selection.x, selection.y, selection.w, selection.h); ctx.clip(); }

            if (l.alphaLock && tools.current !== 'eraser') { ctx.globalCompositeOperation = 'source-atop'; } 
            else if (tools.current === 'eraser') { ctx.globalCompositeOperation = 'destination-out'; } 
            else { ctx.globalCompositeOperation = 'source-over'; }

            const pressure = e.pressure !== 0 ? e.pressure : 0.5;
            points = []; points.push({ x, y, pressure });

            if (tools.current === 'fill') {
                if(!l.alphaLock) ctx.globalCompositeOperation = 'source-over'; 
                floodFill(ctx, Math.floor(x), Math.floor(y), tools.color); 
                isDrawing = false; ctx.restore(); return;
            }

            const allPresets = [...brushLibrary.pencil, ...brushLibrary.brush];
            const preset = allPresets.find(p => p.id === tools.brushType);
            let currentOpacity = tools.opacity;
            let currentBlur = 0;
            let currentCap = 'round';
            let currentJoin = 'round';

            if (tools.current === 'eraser') {
                 if (tools.eraserType === 'soft') { currentBlur = tools.size; } 
                 currentOpacity = 1;
            } else if (preset) {
                currentOpacity = preset.opacity * tools.opacity;
                currentBlur = preset.blur;
                currentCap = preset.type;
                currentJoin = preset.type === 'square' ? 'bevel' : 'round';
            }

            ctx.lineCap = currentCap; ctx.lineJoin = currentJoin;
            ctx.strokeStyle = tools.color; ctx.fillStyle = tools.color;
            ctx.globalAlpha = currentOpacity;
            
            if (currentBlur > 0) { ctx.shadowBlur = currentBlur * 2; ctx.shadowColor = (tools.current === 'eraser') ? 'rgba(0,0,0,1)' : tools.color; } else { ctx.shadowBlur = 0; }

            if (['rect', 'circle', 'triangle'].includes(tools.current)) {
                snapshot = ctx.getImageData(0,0, config.width, config.height); ctx.beginPath();
            }
        }

        function onMouseMove(e) {
            if (isPanning) {
                config.panX += e.clientX - startPanX; config.panY += e.clientY - startPanY;
                startPanX = e.clientX; startPanY = e.clientY; updateCanvasTransform(); return;
            }

            const rect = wrapper.getBoundingClientRect();
            let rawX = (e.clientX - rect.left) / config.zoom;
            let rawY = (e.clientY - rect.top) / config.zoom;

            if (isDrawing && tools.current === 'motionpath') {
                motionPathPoints.push({x: rawX, y: rawY});
                const svg = document.getElementById('motion-path-svg');
                let pathStr = `M ${motionPathPoints[0].x} ${motionPathPoints[0].y}`;
                for(let i=1; i<motionPathPoints.length; i++) pathStr += ` L ${motionPathPoints[i].x} ${motionPathPoints[i].y}`;
                svg.innerHTML = `<path d="${pathStr}" class="motion-path-line"/>`;
                return;
            }

            if (isSelecting) {
                const w = rawX - selStart.x; const h = rawY - selStart.y;
                const selBox = document.getElementById('selection-box');
                selBox.style.left = (w < 0 ? rawX : selStart.x) + 'px'; selBox.style.top = (h < 0 ? rawY : selStart.y) + 'px';
                selBox.style.width = Math.abs(w) + 'px'; selBox.style.height = Math.abs(h) + 'px'; return;
            }

            if ((tools.current === 'eyedropper' || isAltDown) && e.buttons === 1) { pickColor(rawX, rawY); return; }

            if (!isDrawing) return;
            const ctx = getActiveCtx();

            if (tools.current === 'move' && moveSnapshot) {
                const dx = rawX - moveStart.x; const dy = rawY - moveStart.y;
                ctx.clearRect(0,0, config.width, config.height); ctx.putImageData(moveSnapshot, dx, dy); return;
            }

            if (['rect', 'circle', 'triangle'].includes(tools.current)) {
                ctx.putImageData(snapshot, 0, 0); drawShape(ctx, points[0].x, points[0].y, rawX, rawY); return;
            }

            let x = rawX; let y = rawY;
            if (tools.stabilizer > 0) {
                const factor = 1 - (tools.stabilizer * 0.08); 
                x = lastX + (rawX - lastX) * factor; y = lastY + (rawY - lastY) * factor;
                lastX = x; lastY = y;
            } else { lastX = rawX; lastY = rawY; }

            const usePressure = document.getElementById('pressure-chk').checked;
            const pressure = (usePressure && e.pointerType === 'pen') ? e.pressure : 0.5;
            points.push({ x, y, pressure });

            drawSymmetricStroke(ctx, points, usePressure);
        }

        function onMouseUp(e) {
            if (isPanning) { isPanning = false; viewport.classList.remove('panning'); viewport.releasePointerCapture(e.pointerId); return; }
            if (isSelecting) {
                isSelecting = false; const selBox = document.getElementById('selection-box');
                const sb = selBox.style;
                selection = { x: parseFloat(sb.left), y: parseFloat(sb.top), w: parseFloat(sb.width), h: parseFloat(sb.height) };
                if(selection.w < 2 || selection.h < 2) { selection = null; selBox.style.display = 'none'; }
                viewport.releasePointerCapture(e.pointerId); return;
            }
            if (isDrawing) {
                if (tools.current === 'motionpath') {
                    const l = layers.find(x => x.id === activeLayerId);
                    if(l) {
                        l.anim.usePath = true;
                        l.anim.motionPath = [...motionPathPoints];
                        alert(`Motion path recorded for ${l.name}. Go to 'Animator' tab to play.`);
                    }
                } else {
                    const ctx = getActiveCtx();
                    if(ctx) { ctx.shadowBlur = 0; ctx.restore(); ctx.globalCompositeOperation = 'source-over'; }
                    saveHistory(layers.find(x => x.id === activeLayerId));
                }
                isDrawing = false; viewport.releasePointerCapture(e.pointerId); points = [];
            }
        }

        // --- DRAWING HELPERS ---
        function drawSymmetricStroke(ctx, points, usePressure) {
            if(points.length < 3) {
                 const b = points[points.length-1];
                 const size = tools.size * (usePressure ? (b.pressure * 2) : 1);
                 drawSymmetryPoints(ctx, b.x, b.y, size, true);
                 return;
            }
            const p0 = points[points.length - 3]; const p1 = points[points.length - 2]; const p2 = points[points.length - 1];
            const cp = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 }; 
            const cp2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const size = tools.size * (usePressure ? (p1.pressure * 2) : 1);
            
            const segments = getSymmetrySegments(cp.x, cp.y, p1.x, p1.y, cp2.x, cp2.y);
            ctx.lineWidth = size;
            segments.forEach(seg => {
                ctx.beginPath(); 
                ctx.moveTo(seg.s.x, seg.s.y); 
                ctx.quadraticCurveTo(seg.c.x, seg.c.y, seg.e.x, seg.e.y);
                ctx.stroke();

                if (tools.roughness > 0 && tools.current !== 'eraser') {
                    const dist = Math.hypot(seg.e.x - seg.s.x, seg.e.y - seg.s.y);
                    if (dist > 1) {
                         const density = tools.roughness * 10;
                         for(let i=0; i<density; i++) {
                             const rx = (Math.random() - 0.5) * size * 1.5;
                             const ry = (Math.random() - 0.5) * size * 1.5;
                             ctx.fillRect(seg.e.x + rx, seg.e.y + ry, 1, 1);
                         }
                    }
                }
            });
        }
        function drawSymmetryPoints(ctx, x, y, size, fill) {
            const pts = getSymmetryPoints(x, y);
            pts.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x, p.y, size / 2, 0, Math.PI * 2, !0); if(fill) ctx.fill(); else ctx.stroke();
            });
        }
        function getSymmetryPoints(x, y) {
            const cx = config.width / 2; const cy = config.height / 2;
            let pts = [{x,y}];
            if(tools.symmetry === 'vertical' || tools.symmetry === 'quad' || tools.symmetry === 'radial') pts.push({ x: config.width - x, y: y });
            if(tools.symmetry === 'horizontal' || tools.symmetry === 'quad') {
                let newPts = []; pts.forEach(p => newPts.push({ x: p.x, y: config.height - p.y })); pts = pts.concat(newPts);
            }
            if(tools.symmetry === 'radial') {
                 let radPts = [];
                 for(let i=1; i<6; i++) {
                     let angle = (Math.PI / 3) * i;
                     let dx = x - cx; let dy = y - cy;
                     let rx = dx * Math.cos(angle) - dy * Math.sin(angle);
                     let ry = dx * Math.sin(angle) + dy * Math.cos(angle);
                     radPts.push({ x: cx + rx, y: cy + ry });
                     let dx2 = (config.width - x) - cx; 
                     let rx2 = dx2 * Math.cos(angle) - dy * Math.sin(angle);
                     let ry2 = dx2 * Math.sin(angle) + dy * Math.cos(angle);
                     radPts.push({ x: cx + rx2, y: cy + ry2 });
                 }
                 pts = pts.concat(radPts);
            }
            return pts;
        }
        function getSymmetrySegments(sx, sy, cx, cy, ex, ey) {
             const sPts = getSymmetryPoints(sx, sy); const cPts = getSymmetryPoints(cx, cy); const ePts = getSymmetryPoints(ex, ey);
             let segs = []; for(let i=0; i<sPts.length; i++) segs.push({ s: sPts[i], c: cPts[i], e: ePts[i] });
             return segs;
        }
        function syncSettings(type, val) {
            if(type === 'size') { tools.size = parseInt(val); if(tools.current === 'eraser') tools.eraserSize = tools.size; document.getElementById('opt-size').value = val; document.getElementById('opt-size-val').innerText = val; }
            else if (type === 'opacity') { tools.opacity = val / 100; document.getElementById('opt-op').value = val; document.getElementById('opt-op-val').innerText = val; }
            else if (type === 'color') { tools.color = val; document.getElementById('main-color').value = val; }
            else if (type === 'stabilizer') { tools.stabilizer = parseInt(val); document.getElementById('stab-val').innerText = val; }
            else if (type === 'type') { 
                if(tools.current === 'eraser') { tools.eraserType = val; } 
                else { tools.brushType = val; const allPresets = [...brushLibrary.pencil, ...brushLibrary.brush]; const preset = allPresets.find(p => p.id === val); if(preset) { tools.roughness = preset.rough || 0; } }
            }
        }

        // --- HELPERS ---
        function renderLayers() { 
            const list = document.getElementById('layers-container'); list.innerHTML = '';
            layers.forEach(l => {
                const el = document.createElement('div');
                el.className = `layer-item ${l.id === activeLayerId ? 'active' : ''}`;
                el.onclick = (e) => { if (!e.target.classList.contains('vis-icon') && !e.target.classList.contains('lock-icon')) setActiveLayer(l.id); };
                const vis = document.createElement('div'); vis.className = 'vis-icon'; vis.innerHTML = l.visible ? 'üëÅ' : '‚úï'; vis.onclick = () => toggleVis(l.id);
                const name = document.createElement('div'); name.className = 'layer-name'; name.innerHTML = `${l.name} ${l.blendMode !== 'normal' ? `<span class="layer-mode-tag">${l.blendMode}</span>` : ''}`;
                const lock = document.createElement('div'); lock.className = `lock-icon ${l.alphaLock ? 'locked' : ''}`; lock.innerHTML = l.alphaLock ? 'üîí' : 'üîì';
                lock.onclick = () => { l.alphaLock = !l.alphaLock; if(l.id === activeLayerId) document.getElementById('alpha-lock-chk').checked = l.alphaLock; renderLayers(); };
                el.appendChild(vis); el.appendChild(name); el.appendChild(lock); list.appendChild(el);
            });
            renderTimeline();
        }
        function setActiveLayer(id) { 
            activeLayerId = id; renderLayers(); 
            const l = layers.find(x => x.id === id);
            if(l) {
                const valPercent = Math.round(l.opacity * 100);
                document.getElementById('layer-op-slider').value = valPercent;
                document.getElementById('layer-op-val').innerText = valPercent;
                document.getElementById('blend-mode-select').value = l.blendMode;
                document.getElementById('alpha-lock-chk').checked = l.alphaLock;
            }
        }
        function toggleVis(id) { const l = layers.find(x => x.id === id); l.visible = !l.visible; l.canvas.style.display = l.visible ? 'block' : 'none'; renderLayers(); }
        function deleteLayer() { if (layers.length <= 1) return alert("Min 1 layer required"); const l = layers.find(x => x.id === activeLayerId); l.canvas.remove(); layers = layers.filter(x => x.id !== activeLayerId); setActiveLayer(layers[layers.length-1].id); }
        function updateLayerOpacity(val) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; l.opacity = val / 100; l.canvas.style.opacity = l.opacity; document.getElementById('layer-op-val').innerText = val; }
        function updateLayerBlendMode(mode) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; l.blendMode = mode; l.canvas.style.mixBlendMode = mode; renderLayers(); }
        function toggleAlphaLock(checked) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; l.alphaLock = checked; renderLayers(); }
        function applyTemplate(type) { const l = addLayer('Template ' + type); const ctx = l.ctx; const w = config.width; const h = config.height; const pad = 40; ctx.strokeStyle = '#000000'; ctx.lineWidth = 3; if (type === '4koma') { const panelH = (h - (pad * 5)) / 4; for(let i=0; i<4; i++) ctx.strokeRect(pad * 4, pad + (i * (panelH + pad)), w - (pad * 8), panelH); } else if (type === 'standard') { ctx.strokeRect(pad, pad, w - (pad*2), h * 0.4); ctx.strokeRect(pad, h*0.4 + pad*2, (w/2) - pad*1.5, h * 0.45); ctx.strokeRect(w/2 + pad/2, h*0.4 + pad*2, (w/2) - pad*1.5, h * 0.45); } else if (type === 'action') { ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(w*0.6, pad); ctx.lineTo(w*0.4, h-pad); ctx.lineTo(pad, h-pad); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(w*0.6 + pad, pad); ctx.lineTo(w-pad, pad); ctx.lineTo(w-pad, h-pad); ctx.lineTo(w*0.4 + pad, h-pad); ctx.closePath(); ctx.stroke(); } else if (type === 'dialog') { const rowH = (h - (pad*4)) / 3; ctx.strokeRect(pad, pad, w-pad*2, rowH); ctx.strokeRect(pad, pad*2 + rowH, w-pad*2, rowH); ctx.strokeRect(pad, pad*3 + rowH*2, w-pad*2, rowH); } saveHistory(l); }
        function applyFilter(type) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; const ctx = l.ctx; const w = config.width; const h = config.height; saveHistory(l); ctx.save(); if (type === 'blur') { const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h; const tCtx = tmp.getContext('2d'); tCtx.filter = 'blur(5px)'; tCtx.drawImage(l.canvas, 0, 0); ctx.clearRect(0, 0, w, h); ctx.drawImage(tmp, 0, 0); } else { const imgData = ctx.getImageData(0, 0, w, h); const d = imgData.data; for (let i = 0; i < d.length; i += 4) { if (d[i+3] === 0) continue; if (type === 'grayscale') { const avg = (d[i] + d[i+1] + d[i+2]) / 3; d[i] = avg; d[i+1] = avg; d[i+2] = avg; } else if (type === 'invert') { d[i] = 255 - d[i]; d[i+1] = 255 - d[i+1]; d[i+2] = 255 - d[i+2]; } else if (type === 'brightness') { d[i] += 40; d[i+1] += 40; d[i+2] += 40; } } ctx.putImageData(imgData, 0, 0); } ctx.restore(); }
        function pickColor(x, y) { const tmp = document.createElement('canvas'); tmp.width = 1; tmp.height = 1; const tCtx = tmp.getContext('2d'); tCtx.fillStyle = '#ffffff'; tCtx.fillRect(0,0,1,1); layers.forEach(l => { if (l.visible) { tCtx.globalAlpha = l.opacity; tCtx.globalCompositeOperation = (l.blendMode === 'normal') ? 'source-over' : l.blendMode; tCtx.drawImage(l.canvas, x, y, 1, 1, 0, 0, 1, 1); } }); const p = tCtx.getImageData(0,0,1,1).data; const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1); syncSettings('color', hex); }
        function drawShape(ctx, x1, y1, x2, y2) { ctx.beginPath(); ctx.lineWidth = tools.size; const w = x2 - x1; const h = y2 - y1; const fill = document.getElementById('fill-shape-chk').checked; if (tools.current === 'rect') { fill ? ctx.fillRect(x1, y1, w, h) : ctx.strokeRect(x1, y1, w, h); } else if (tools.current === 'circle') { ctx.ellipse(x1 + w/2, y1 + h/2, Math.abs(w/2), Math.abs(h/2), 0, 0, 2 * Math.PI); fill ? ctx.fill() : ctx.stroke(); } else if (tools.current === 'triangle') { ctx.moveTo(x1 + w / 2, y1); ctx.lineTo(x1, y1 + h); ctx.lineTo(x1 + w, y1 + h); ctx.closePath(); fill ? ctx.fill() : ctx.stroke(); } }
        function floodFill(ctx, x, y, hexColor) { const r = parseInt(hexColor.slice(1,3), 16); const g = parseInt(hexColor.slice(3,5), 16); const b = parseInt(hexColor.slice(5,7), 16); const imgData = ctx.getImageData(0,0, config.width, config.height); const data = imgData.data; const pos = (y * config.width + x) * 4; const sr = data[pos], sg = data[pos+1], sb = data[pos+2], sa = data[pos+3]; if (sr===r && sg===g && sb===b && sa===255) return; const stack = [[x,y]]; while(stack.length) { const [cx, cy] = stack.pop(); const idx = (cy * config.width + cx) * 4; if (cx>=0 && cx<config.width && cy>=0 && cy<config.height) { if (data[idx]===sr && data[idx+1]===sg && data[idx+2]===sb && data[idx+3]===sa) { data[idx]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=255; stack.push([cx+1, cy]); stack.push([cx-1, cy]); stack.push([cx, cy+1]); stack.push([cx, cy-1]); } } } ctx.putImageData(imgData, 0, 0); saveHistory(layers.find(x => x.id === activeLayerId)); }
        function saveHistory(layer) { layer.historyPtr++; if (layer.historyPtr < layer.history.length) layer.history.length = layer.historyPtr; if (layer.history.length > 20) { layer.history.shift(); layer.historyPtr--; } layer.history.push(layer.canvas.toDataURL()); }
        function layerUndo() { const l = layers.find(x => x.id === activeLayerId); if (!l || l.historyPtr <= 0) return; l.historyPtr--; const img = new Image(); img.src = l.history[l.historyPtr]; img.onload = () => { l.ctx.clearRect(0,0, config.width, config.height); l.ctx.drawImage(img, 0, 0); }; }
        function triggerUpload() { document.getElementById('upload-input').click(); }
        function processUpload(input) { if(input.files && input.files[0]) { const reader = new FileReader(); reader.onload = (e) => { const img = new Image(); img.onload = () => { const l = addLayer('Imported Image'); const aspect = img.width / img.height; let drawW = img.width; let drawH = img.height; if (drawW > config.width) { drawW = config.width; drawH = drawW / aspect; } if (drawH > config.height) { drawH = config.height; drawW = drawH * aspect; } const x = (config.width - drawW) / 2; const y = (config.height - drawH) / 2; l.ctx.drawImage(img, x, y, drawW, drawH); saveHistory(l); }; img.src = e.target.result; }; reader.readAsDataURL(input.files[0]); } input.value = ''; }
        function exportImage() { const tmp = document.createElement('canvas'); tmp.width = config.width; tmp.height = config.height; const tCtx = tmp.getContext('2d'); layers.forEach(l => { if(l.visible) { tCtx.globalAlpha = l.opacity; tCtx.globalCompositeOperation = (l.blendMode === 'normal') ? 'source-over' : l.blendMode; tCtx.drawImage(l.canvas, 0, 0); } }); const link = document.createElement('a'); link.download = 'fercy-studio-export.png'; link.href = tmp.toDataURL(); link.click(); }
        function toggleTheme() { const b = document.body; b.setAttribute('data-theme', b.getAttribute('data-theme')==='light'?'dark':'light'); }
        function setGuides(g) { guidesVisible = g; document.getElementById('guides-overlay').style.display = g ? 'block' : 'none'; }
        function toggleGuides() { guidesVisible = !guidesVisible; setGuides(guidesVisible); }
        function toggleRecord() { toggleRecord(); } 
        async function toggleRecord() { 
             const btn = document.getElementById('rec-btn'); const txt = document.getElementById('rec-text');
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { mediaSource: "screen" } });
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: "video/webm" });
                        const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "fercy-process.webm"; a.click();
                        recordedChunks = []; isRecording = false; btn.classList.remove('recording'); txt.innerText = "Record";
                    };
                    mediaRecorder.start(); isRecording = true; btn.classList.add('recording'); txt.innerText = "Stop Rec";
                    stream.getVideoTracks()[0].onended = () => { if(isRecording) mediaRecorder.stop(); };
                } catch (err) { alert("Recording cancelled."); }
            } else { mediaRecorder.stop(); mediaRecorder.stream.getTracks().forEach(track => track.stop()); }
        }
        function updateCanvasTransform() { const wrapper = document.getElementById('canvas-wrapper'); wrapper.style.transform = `translate(calc(-50% + ${config.panX}px), calc(-50% + ${config.panY}px)) scale(${config.zoom})`; drawRulers(); }
        function zoomIn() { if (config.zoom < 5.0) { config.zoom += 0.1; updateCanvasTransform(); updateZoomDisplay(); } }
        function zoomOut() { if (config.zoom > 0.1) { config.zoom -= 0.1; updateCanvasTransform(); updateZoomDisplay(); } }
        function resetZoom() { config.zoom = 1.0; config.panX = 0; config.panY = 0; updateCanvasTransform(); updateZoomDisplay(); }
        function updateZoomDisplay() { document.getElementById('zoom-text').innerText = Math.round(config.zoom * 100) + '%'; }
        document.getElementById('viewport').addEventListener('wheel', (e) => { e.preventDefault(); if (e.deltaY < 0) zoomIn(); else zoomOut(); }, { passive: false });
        function restoreSession() { try { const settings = JSON.parse(localStorage.getItem('fercy_settings')); const imgData = localStorage.getItem('fercy_active_layer'); if(settings && imgData) { document.getElementById('canvas-w').value = settings.w; document.getElementById('canvas-h').value = settings.h; initCanvas(); const img = new Image(); img.onload = () => { const l = layers.find(x => x.id === activeLayerId); l.ctx.drawImage(img, 0, 0); saveHistory(l); }; img.src = imgData; } else { alert("No session found."); } } catch(e) { alert("Error restoring."); } }
        function startAutosave() { autosaveInterval = setInterval(() => { const l = layers.find(x => x.id === activeLayerId); if(l) { const status = document.getElementById('autosave-status'); status.classList.add('visible'); try { localStorage.setItem('fercy_active_layer', l.canvas.toDataURL()); localStorage.setItem('fercy_settings', JSON.stringify({ w: config.width, h: config.height, tools })); setTimeout(() => status.classList.remove('visible'), 1000); } catch(e) { console.log("Storage full"); } } }, 30000); }
    </script>
</body>
</html>
