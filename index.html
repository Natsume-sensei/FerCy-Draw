<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FerCy Draw - Alpha Edition</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --primary: #00e5ff;
            --accent: #7000ff;
            --bg-dark: #121212;
            --panel-bg: #1e1e1e;
            --header-bg: #252525;
            --text-main: #e0e0e0;
            --text-muted: #aaaaaa;
            --border: 1px solid #333;
            --active-item: #333;
            --canvas-shadow: 0 0 30px rgba(0,0,0,0.5);
            --rec-color: #ff4444;
            --selection-border: 1px dashed #fff;
        }

        [data-theme="light"] {
            --primary: #007bff;
            --accent: #6610f2;
            --bg-dark: #e9ecef;
            --panel-bg: #ffffff;
            --header-bg: #f8f9fa;
            --text-main: #212529;
            --text-muted: #6c757d;
            --border: 1px solid #dee2e6;
            --active-item: #e2e6ea;
            --canvas-shadow: 0 0 20px rgba(0,0,0,0.1);
            --selection-border: 1px dashed #000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
            touch-action: none; 
        }

        /* --- HEADER --- */
        .main-header {
            height: 35px; background: var(--header-bg); border-bottom: var(--border);
            display: flex; align-items: center; padding: 0 10px; font-size: 0.85rem;
        }
        .brand { font-weight: bold; color: var(--primary); margin-right: 20px; letter-spacing: 1px; }
        .menu-item { padding: 5px 10px; cursor: pointer; color: var(--text-muted); border-radius: 4px; transition: 0.2s;}
        .menu-item:hover { color: var(--text-main); background: rgba(255,255,255,0.05); }
        
        .rec-btn { color: var(--text-muted); display:flex; align-items:center; gap:5px; }
        .rec-btn.recording { color: var(--rec-color); animation: pulse 1.5s infinite; font-weight: bold; }
        .rec-dot { width: 8px; height: 8px; background: currentColor; border-radius: 50%; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* --- OPTIONS BAR --- */
        .options-bar {
            height: 45px; background: var(--panel-bg); border-bottom: var(--border);
            display: flex; align-items: center; padding: 0 15px; gap: 15px;
        }

        .zoom-controls {
            display: flex; align-items: center; gap: 5px;
            background: rgba(255,255,255,0.05); padding: 3px 8px; border-radius: 4px; border: 1px solid var(--border);
        }
        .zoom-btn { background: none; border: none; color: var(--text-main); cursor: pointer; font-weight: bold; width: 20px; }
        .zoom-btn:hover { color: var(--primary); }
        .zoom-display { font-size: 0.8rem; min-width: 40px; text-align: center; }

        .toggle-opt { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; cursor: pointer; }
        .toggle-opt input { accent-color: var(--primary); width: auto; height: auto; }
        
        select.opt-select {
            background: var(--bg-dark); color: var(--text-main); border: 1px solid var(--border);
            padding: 2px 5px; border-radius: 4px; font-size: 0.8rem; outline: none; min-width: 120px;
        }

        /* --- WORKSPACE --- */
        .workspace { display: flex; flex: 1; overflow: hidden; position: relative; }

        .tools-panel {
            width: 50px; background: var(--panel-bg); border-right: var(--border);
            display: flex; flex-direction: column; align-items: center; padding: 10px 0; gap: 5px; z-index: 10;
        }
        
        .tool-btn {
            width: 36px; height: 36px; border: none; background: transparent; color: var(--text-muted);
            border-radius: 4px; cursor: pointer; font-size: 1.2rem;
            display: flex; justify-content: center; align-items: center; transition: 0.2s; position: relative;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.1); color: var(--primary); }
        .tool-btn.active { background: var(--active-item); color: var(--primary); border-left: 3px solid var(--primary); }
        .shortcut-hint { position: absolute; bottom: 1px; right: 2px; font-size: 0.5rem; opacity: 0.5; }
        
        .separator { width: 80%; height: 1px; background: var(--border); margin: 5px 0; }

        /* --- CANVAS --- */
        .viewport {
            flex: 1; background: var(--bg-dark); overflow: hidden; position: relative; cursor: default; touch-action: none; 
        }
        .viewport-bg {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background-image: radial-gradient(var(--text-muted) 1px, transparent 1px);
            background-size: 20px 20px; opacity: 0.2; pointer-events: none;
        }
        #canvas-wrapper {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; box-shadow: var(--canvas-shadow); cursor: crosshair;
            transform-origin: center center; touch-action: none; 
        }
        .drawing-canvas {
            position: absolute; top: 0; left: 0; pointer-events: none;
            transition: opacity 0.1s ease;
        }
        #selection-box {
            position: absolute; border: 2px dashed #00e5ff; background: rgba(0, 229, 255, 0.1);
            pointer-events: none; display: none; z-index: 999;
        }

        /* --- RIGHT SIDEBAR --- */
        .sidebar-right {
            width: 280px; background: var(--panel-bg); border-left: var(--border);
            display: flex; flex-direction: column; z-index: 10; overflow-y: auto;
        }

        .panel-section { padding: 15px; border-bottom: var(--border); }
        .section-title {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--text-muted); margin-bottom: 10px; font-weight: bold;
        }

        input[type="range"] { width: 100%; accent-color: var(--primary); height: 4px; background: #444; border-radius: 2px; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--primary); border-radius: 50%; cursor: pointer; }
        
        .color-well {
            width: 100%; height: 35px; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; position: relative;
        }
        input[type="color"] { width: 150%; height: 150%; position: absolute; top: -10px; left: -10px; cursor: pointer; border: none; }

        .layer-controls { padding: 10px 15px; border-bottom: var(--border); font-size: 0.85rem; }
        
        .blend-select {
            width: 100%; padding: 5px; background: var(--bg-dark); color: var(--text-main);
            border: 1px solid var(--border); border-radius: 4px; margin-bottom: 10px; font-size: 0.8rem;
        }

        .layers-list {
            flex: 1; overflow-y: auto; background: rgba(0,0,0,0.1); display: flex; flex-direction: column-reverse; min-height: 150px;
        }
        .layer-item {
            display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; font-size: 0.85rem;
        }
        .layer-item:hover { background: rgba(255,255,255,0.05); }
        .layer-item.active { background: var(--active-item); border-left: 3px solid var(--primary); }
        .vis-icon { width: 20px; text-align: center; color: var(--text-muted); margin-right: 8px; }
        .vis-icon:hover { color: #fff; }
        .layer-name { flex: 1; }
        .layer-mode-tag { font-size: 0.6rem; padding: 2px 4px; background: rgba(0,0,0,0.3); border-radius: 3px; margin-left: 5px; color: var(--primary); }
        
        .lock-icon { width: 20px; text-align: center; color: var(--text-muted); margin-left: 5px; transition:0.2s; }
        .lock-icon:hover, .lock-icon.locked { color: var(--primary); }

        .manga-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .manga-btn {
            padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            color: var(--text-muted); font-size: 0.8rem; cursor: pointer; border-radius: 4px;
        }
        .manga-btn:hover { background: var(--primary); color: #000; }

        /* Filter Buttons Grid */
        .filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .filter-btn {
            padding: 8px; background: var(--bg-dark); border: 1px solid var(--border);
            color: var(--text-main); font-size: 0.75rem; cursor: pointer; border-radius: 4px;
        }
        .filter-btn:hover { border-color: var(--primary); color: var(--primary); }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 999;
            display: flex; justify-content: center; align-items: center;
            visibility: hidden; opacity: 0; transition: 0.3s;
        }
        .modal-overlay.open { visibility: visible; opacity: 1; }
        .modal-box {
            background: var(--panel-bg); padding: 25px; border-radius: 8px;
            width: 350px; border: 1px solid var(--primary);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .modal-box h2 { color: var(--primary); margin-bottom: 20px; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
        .input-group input { 
            width: 100%; padding: 8px; background: var(--bg-dark); 
            border: 1px solid var(--border); color: var(--text-main); border-radius: 4px;
        }
        .btn-main {
            width: 100%; padding: 10px; background: var(--primary); color: #000;
            border: none; border-radius: 4px; font-weight: bold; cursor: pointer;
        }

        .viewport.hand-active #canvas-wrapper { cursor: grab; }
        .viewport.hand-active.panning #canvas-wrapper { cursor: grabbing; }
        .hidden { display: none !important; }
        .row { display: flex; justify-content: space-between; margin-bottom: 5px;}
        
        /* Autosave Indicator */
        #autosave-status {
            font-size: 0.7rem; color: var(--text-muted); margin-left: 10px; opacity: 0; transition: opacity 0.5s;
        }
        #autosave-status.visible { opacity: 1; }
    </style>
</head>
<body>

    <div class="modal-overlay" id="new-modal">
        <div class="modal-box">
            <h2>New Project</h2>
            <div class="input-group">
                <label>Width (px)</label>
                <input type="number" id="canvas-w" value="1280">
            </div>
            <div class="input-group">
                <label>Height (px)</label>
                <input type="number" id="canvas-h" value="720">
            </div>
            <button class="btn-main" onclick="initCanvas()">Create Canvas</button>
            <button class="btn-main" onclick="restoreSession()" style="margin-top:10px; background:#444; color:#fff;">Restore Last Session</button>
        </div>
    </div>

    <input type="file" id="upload-input" style="display:none" accept="image/*" onchange="processUpload(this)">

    <header class="main-header">
        <div class="brand">FerCy Draw Alpha Edition</div>
        <div class="menu-item" onclick="document.getElementById('new-modal').classList.add('open')">File</div>
        <div class="menu-item" onclick="triggerUpload()">Import</div>
        <div class="menu-item" onclick="exportImage()">Export</div>
        <div class="menu-item" onclick="toggleTheme()">Theme</div>
        <div class="menu-item rec-btn" id="rec-btn" onclick="toggleRecord()">
            <div class="rec-dot"></div> <span id="rec-text">Record</span>
        </div>
        <div id="autosave-status">Saving...</div>
        <div style="flex:1"></div>
        <div class="menu-item" style="font-size:0.7rem; opacity:0.7;">v1.0</div>
    </header>

    <div class="options-bar">
        <div style="font-size:0.85rem; font-weight:bold; width: 80px;" id="tool-name-display">Tool: Pencil</div>
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
            <span class="zoom-display" id="zoom-text">100%</span>
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="resetZoom()" style="font-size:0.7rem; width:auto; margin-left:5px;">R</button>
        </div>
        <div style="width:1px; height:20px; background:var(--border)"></div>
        
        <label class="toggle-opt">
            <input type="checkbox" id="pressure-chk" checked> Pressure
        </label>

        <div style="width:1px; height:20px; background:var(--border)"></div>
        
        <div style="display:flex; align-items:center; gap:5px; width: 120px;">
            <span style="font-size:0.8rem">Stab: <span id="stab-val">0</span></span>
            <input type="range" id="stab-slider" min="0" max="10" value="0" oninput="syncSettings('stabilizer', this.value)">
        </div>

        <div style="width:1px; height:20px; background:var(--border)"></div>

        <div style="display:flex; align-items:center; gap:10px; width: 130px;">
            <span style="font-size:0.8rem">Size: <span id="opt-size-val">5</span></span>
            <input type="range" id="opt-size" min="1" max="100" value="5" oninput="syncSettings('size', this.value)">
        </div>
        <div style="width:1px; height:20px; background:var(--border)"></div>
        
        <select class="opt-select" id="tool-type-select" onchange="syncSettings('type', this.value)">
            </select>

        <div style="flex:1"></div>
        <button onclick="layerUndo()" style="background:none; border:1px solid var(--border); color:var(--text-main); padding:4px 10px; border-radius:4px; cursor:pointer;">‚Ü© Undo</button>
    </div>

    <div class="workspace">
        <div class="tools-panel">
            <button class="tool-btn active" onclick="setTool('pencil')" title="Pencil/Brush (B)">üñå<span class="shortcut-hint">B</span></button>
            <button class="tool-btn" onclick="setTool('eraser')" title="Eraser (E)">‚å´<span class="shortcut-hint">E</span></button>
            
            <div class="separator"></div>
            
            <button class="tool-btn" onclick="setTool('hand')" title="Hand Tool (Space)">‚úã</button>
            <button class="tool-btn" onclick="setTool('move')" title="Move Layer (V)">‚¨ç<span class="shortcut-hint">V</span></button>
            <button class="tool-btn" onclick="setTool('select')" title="Selection (M)">‚õ∂<span class="shortcut-hint">M</span></button>
            <button class="tool-btn" onclick="setTool('eyedropper')" title="Eyedropper (Alt)">üíâ<span class="shortcut-hint">Alt</span></button>
            
            <div class="separator"></div>
            
            <button class="tool-btn" onclick="setTool('fill')" title="Flood Fill">üíß</button>
            <button class="tool-btn" onclick="setTool('rect')" title="Rectangle">‚¨ú</button>
            <button class="tool-btn" onclick="setTool('circle')" title="Circle">‚óØ</button>
            <button class="tool-btn" onclick="setTool('triangle')" title="Triangle">‚ñ≥</button>
        </div>

        <div class="viewport" id="viewport">
            <div class="viewport-bg"></div>
            <div id="canvas-wrapper">
                <div id="selection-box"></div>
            </div>
        </div>

        <div class="sidebar-right">
            <div class="panel-section">
                <div class="section-title">Color & Shapes</div>
                <div class="color-well">
                    <input type="color" id="main-color" value="#000000" onchange="syncSettings('color', this.value)">
                </div>
                <div style="margin-top:10px;">
                    <label style="display:flex; align-items:center; gap:8px; font-size:0.85rem; cursor:pointer;">
                        <input type="checkbox" id="fill-shape-chk"> Fill Shapes (2D)
                    </label>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">Filters (Active Layer)</div>
                <div class="filter-grid">
                    <button class="filter-btn" onclick="applyFilter('blur')">Blur 5px</button>
                    <button class="filter-btn" onclick="applyFilter('grayscale')">Grayscale</button>
                    <button class="filter-btn" onclick="applyFilter('invert')">Invert</button>
                    <button class="filter-btn" onclick="applyFilter('brightness')">Brighten</button>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-title">Manga Templates</div>
                <div class="manga-grid">
                    <button class="manga-btn" onclick="applyTemplate('4koma')">4-Koma</button>
                    <button class="manga-btn" onclick="applyTemplate('standard')">Standard</button>
                    <button class="manga-btn" onclick="applyTemplate('action')">Action</button>
                    <button class="manga-btn" onclick="applyTemplate('dialog')">Dialog</button>
                </div>
            </div>

            <div class="panel-section" style="padding: 10px; display:flex; gap:5px;">
                <button class="btn-main" onclick="addLayer()" style="font-size:0.8rem;">+ New Layer</button>
                <button class="btn-main" onclick="deleteLayer()" style="background:#d32f2f; width:40px;">üóë</button>
            </div>

            <div class="layer-controls">
                <div class="row">
                    <span>Blend Mode:</span>
                </div>
                <select class="blend-select" id="blend-mode-select" onchange="updateLayerBlendMode(this.value)">
                    <option value="normal">Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                </select>

                <div class="row">
                    <span>Layer Opacity: <span id="layer-op-val">100</span>%</span>
                </div>
                <input type="range" id="layer-op-slider" min="0" max="100" value="100" oninput="updateLayerOpacity(this.value)">
                
                <div style="margin-top:15px; border-top:1px solid var(--border); padding-top:10px;">
                    <label style="display:flex; align-items:center; gap:8px; font-size:0.85rem; cursor:pointer;">
                         <input type="checkbox" id="alpha-lock-chk" onchange="toggleAlphaLock(this.checked)"> 
                         üîí Alpha Lock (Shading)
                    </label>
                </div>
            </div>

            <div class="layers-list" id="layers-container"></div>
        </div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        let config = { width: 1280, height: 720, zoom: 1.0, panX: 0, panY: 0 };
        let tools = { 
            current: 'pencil', 
            size: 5, 
            eraserSize: 20, 
            opacity: 1.0, 
            color: '#000000',
            stabilizer: 0,
            brushType: 'round',
            eraserType: 'hard' // NEW: Eraser type state
        };
        let layers = [];
        let activeLayerId = null;
        let layerCounter = 0;

        let isDrawing = false;
        let isPanning = false;
        let startPanX, startPanY; 
        
        let points = []; 
        let moveStart = { x: 0, y: 0 };
        let moveSnapshot = null;
        
        let selection = null; 
        let isSelecting = false;
        let selStart = { x:0, y:0 };

        let snapshot; 
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        let isSpaceDown = false;
        let isAltDown = false; 
        let previousTool = 'pencil';
        
        let mouseX = 0, mouseY = 0;
        let lastX = 0, lastY = 0;

        window.onload = () => document.getElementById('new-modal').classList.add('open');

        function initCanvas() {
            const w = parseInt(document.getElementById('canvas-w').value);
            const h = parseInt(document.getElementById('canvas-h').value);
            config.width = w; config.height = h;

            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = w + 'px'; wrapper.style.height = h + 'px';
            wrapper.innerHTML = '<div id="selection-box"></div>';
            
            config.zoom = 1.0; config.panX = 0; config.panY = 0;
            updateCanvasTransform(); updateZoomDisplay();

            layers = [];
            addLayer('Background', true);
            addLayer('Layer 1');

            document.getElementById('new-modal').classList.remove('open');
            updateToolOptionsUI(); // Init options
            startAutosave();
        }

        // --- NEW: AUTOSAVE & RESTORE ---
        function startAutosave() {
            setInterval(() => {
                const l = layers.find(x => x.id === activeLayerId);
                if(l) {
                    const status = document.getElementById('autosave-status');
                    status.classList.add('visible');
                    try {
                        localStorage.setItem('fercy_active_layer', l.canvas.toDataURL());
                        localStorage.setItem('fercy_settings', JSON.stringify({ w: config.width, h: config.height, tools }));
                        setTimeout(() => status.classList.remove('visible'), 1000);
                    } catch(e) { console.log("Storage full"); }
                }
            }, 30000); 
        }

        function restoreSession() {
            try {
                const settings = JSON.parse(localStorage.getItem('fercy_settings'));
                const imgData = localStorage.getItem('fercy_active_layer');
                if(settings && imgData) {
                    document.getElementById('canvas-w').value = settings.w;
                    document.getElementById('canvas-h').value = settings.h;
                    initCanvas();
                    const img = new Image();
                    img.onload = () => {
                        const l = layers.find(x => x.id === activeLayerId);
                        l.ctx.drawImage(img, 0, 0);
                        saveHistory(l);
                    };
                    img.src = imgData;
                } else { alert("No session found."); }
            } catch(e) { alert("Error restoring."); }
        }

        // --- SHORTCUTS & INPUT ---
        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            if (e.code === 'Space' && !isSpaceDown) { isSpaceDown = true; previousTool = tools.current; setTool('hand'); }
            if (e.key === 'Alt' && !isAltDown) { e.preventDefault(); isAltDown = true; document.getElementById('canvas-wrapper').style.cursor = 'copy'; }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); layerUndo(); }
            
            if (e.key === '[') { 
                let s = parseInt(document.getElementById('opt-size').value) - 1; 
                if(s<1) s=1; syncSettings('size', s); 
            }
            if (e.key === ']') { 
                let s = parseInt(document.getElementById('opt-size').value) + 1; 
                if(s>100) s=100; syncSettings('size', s); 
            }

            if (!e.ctrlKey && !isSpaceDown && !isAltDown) {
                if (e.key.toLowerCase() === 'b') setTool('pencil');
                if (e.key.toLowerCase() === 'e') setTool('eraser');
                if (e.key.toLowerCase() === 'v') setTool('move');
                if (e.key.toLowerCase() === 'm') setTool('select');
            }
            if (e.key === 'Escape') { selection = null; document.getElementById('selection-box').style.display = 'none'; }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') { isSpaceDown = false; setTool(previousTool); }
            if (e.key === 'Alt') { isAltDown = false; if(tools.current !== 'eyedropper') setTool(tools.current); }
        });

        // --- CORE FUNCTIONS ---
        function updateCanvasTransform() {
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.transform = `translate(calc(-50% + ${config.panX}px), calc(-50% + ${config.panY}px)) scale(${config.zoom})`;
        }
        function zoomIn() { if (config.zoom < 5.0) { config.zoom += 0.1; updateCanvasTransform(); updateZoomDisplay(); } }
        function zoomOut() { if (config.zoom > 0.1) { config.zoom -= 0.1; updateCanvasTransform(); updateZoomDisplay(); } }
        function resetZoom() { config.zoom = 1.0; config.panX = 0; config.panY = 0; updateCanvasTransform(); updateZoomDisplay(); }
        function updateZoomDisplay() { document.getElementById('zoom-text').innerText = Math.round(config.zoom * 100) + '%'; }
        document.getElementById('viewport').addEventListener('wheel', (e) => { e.preventDefault(); if (e.deltaY < 0) zoomIn(); else zoomOut(); }, { passive: false });

        async function toggleRecord() { /* ...Same... */ 
             const btn = document.getElementById('rec-btn'); const txt = document.getElementById('rec-text');
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { mediaSource: "screen" } });
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: "video/webm" });
                        const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "fercy-process.webm"; a.click();
                        recordedChunks = []; isRecording = false; btn.classList.remove('recording'); txt.innerText = "Record";
                    };
                    mediaRecorder.start(); isRecording = true; btn.classList.add('recording'); txt.innerText = "Stop Rec";
                    stream.getVideoTracks()[0].onended = () => { if(isRecording) mediaRecorder.stop(); };
                } catch (err) { alert("Recording cancelled."); }
            } else { mediaRecorder.stop(); mediaRecorder.stream.getTracks().forEach(track => track.stop()); }
        }

        // --- SETTINGS & TOOLS ---
        function setTool(name) {
            // Save Eraser Size
            if(tools.current === 'eraser') tools.eraserSize = tools.size;
            
            tools.current = name;
            
            // Restore size
            if(name === 'eraser') {
                syncSettings('size', tools.eraserSize);
            } 

            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`.tool-btn[onclick="setTool('${name}')"]`);
            if(btn) btn.classList.add('active');
            document.getElementById('tool-name-display').innerText = "Tool: " + name.charAt(0).toUpperCase() + name.slice(1);
            
            const vp = document.getElementById('viewport');
            vp.classList.remove('hand-active');
            const wrapper = document.getElementById('canvas-wrapper');
            
            if (name === 'hand') { vp.classList.add('hand-active'); wrapper.style.cursor = 'grab'; }
            else if (name === 'move') { wrapper.style.cursor = 'move'; }
            else if (name === 'select') { wrapper.style.cursor = 'cell'; }
            else if (name === 'eyedropper') { wrapper.style.cursor = 'copy'; }
            else { wrapper.style.cursor = 'crosshair'; }
            
            updateToolOptionsUI(); // Update Dropdown
        }

        // NEW: Dynamic Dropdown Logic
        function updateToolOptionsUI() {
            const select = document.getElementById('tool-type-select');
            select.innerHTML = '';
            
            if (tools.current === 'eraser') {
                const opts = [
                    {val: 'hard', text: 'Hard Eraser'},
                    {val: 'soft', text: 'Soft Eraser (Blur)'}
                ];
                opts.forEach(o => {
                    const op = document.createElement('option');
                    op.value = o.val; op.innerText = o.text;
                    if(tools.eraserType === o.val) op.selected = true;
                    select.appendChild(op);
                });
            } else {
                // Default Brush Types
                const opts = [
                    {val: 'round', text: 'Pen (Round)'},
                    {val: 'square', text: 'Marker (Square)'},
                    {val: 'hard', text: 'Pencil (Hard)'},
                    {val: 'soft', text: 'Airbrush (Soft)'}
                ];
                opts.forEach(o => {
                    const op = document.createElement('option');
                    op.value = o.val; op.innerText = o.text;
                    if(tools.brushType === o.val) op.selected = true;
                    select.appendChild(op);
                });
            }
        }

        function syncSettings(type, val) {
            if(type === 'size') { 
                tools.size = parseInt(val); 
                if(tools.current === 'eraser') tools.eraserSize = tools.size;
                document.getElementById('opt-size').value = val; 
                document.getElementById('opt-size-val').innerText = val; 
            }
            else if (type === 'opacity') { tools.opacity = val / 100; document.getElementById('opt-op').value = val; document.getElementById('opt-op-val').innerText = val; }
            else if (type === 'color') { tools.color = val; document.getElementById('main-color').value = val; }
            else if (type === 'stabilizer') { tools.stabilizer = parseInt(val); document.getElementById('stab-val').innerText = val; }
            else if (type === 'type') { 
                // Handle different types based on tool
                if(tools.current === 'eraser') tools.eraserType = val;
                else tools.brushType = val;
            }
        }

        // --- LAYER SYSTEM ---
        function addLayer(name = null, isBg = false) {
            layerCounter++; const id = layerCounter; const title = name || `Layer ${id}`;
            const canvas = document.createElement('canvas');
            canvas.width = config.width; canvas.height = config.height;
            canvas.className = 'drawing-canvas'; canvas.style.zIndex = id; canvas.style.opacity = 1.0; 
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
            if (isBg) { ctx.fillStyle = "#ffffff"; ctx.fillRect(0,0,config.width, config.height); }
            document.getElementById('canvas-wrapper').appendChild(canvas);
            
            const layer = { id, name: title, canvas, ctx, visible: true, opacity: 1.0, blendMode: 'normal', alphaLock: false, history: [], historyPtr: -1 };
            layers.push(layer);
            saveHistory(layer);
            setActiveLayer(id);
            return layer;
        }

        function renderLayers() { /* ...Same... */ 
            const list = document.getElementById('layers-container'); list.innerHTML = '';
            layers.forEach(l => {
                const el = document.createElement('div');
                el.className = `layer-item ${l.id === activeLayerId ? 'active' : ''}`;
                el.onclick = (e) => { if (!e.target.classList.contains('vis-icon') && !e.target.classList.contains('lock-icon')) setActiveLayer(l.id); };
                const vis = document.createElement('div'); vis.className = 'vis-icon'; vis.innerHTML = l.visible ? 'üëÅ' : '‚úï'; vis.onclick = () => toggleVis(l.id);
                const name = document.createElement('div'); name.className = 'layer-name'; name.innerHTML = `${l.name} ${l.blendMode !== 'normal' ? `<span class="layer-mode-tag">${l.blendMode}</span>` : ''}`;
                const lock = document.createElement('div'); lock.className = `lock-icon ${l.alphaLock ? 'locked' : ''}`; lock.innerHTML = l.alphaLock ? 'üîí' : 'üîì';
                lock.onclick = () => { l.alphaLock = !l.alphaLock; if(l.id === activeLayerId) document.getElementById('alpha-lock-chk').checked = l.alphaLock; renderLayers(); };
                el.appendChild(vis); el.appendChild(name); el.appendChild(lock); list.appendChild(el);
            });
        }
        function setActiveLayer(id) { 
            activeLayerId = id; renderLayers(); 
            const l = layers.find(x => x.id === id);
            if(l) {
                const valPercent = Math.round(l.opacity * 100);
                document.getElementById('layer-op-slider').value = valPercent;
                document.getElementById('layer-op-val').innerText = valPercent;
                document.getElementById('blend-mode-select').value = l.blendMode;
                document.getElementById('alpha-lock-chk').checked = l.alphaLock;
            }
        }
        function toggleVis(id) { const l = layers.find(x => x.id === id); l.visible = !l.visible; l.canvas.style.display = l.visible ? 'block' : 'none'; renderLayers(); }
        function deleteLayer() { 
            if (layers.length <= 1) return alert("Min 1 layer required");
            const l = layers.find(x => x.id === activeLayerId); l.canvas.remove();
            layers = layers.filter(x => x.id !== activeLayerId); setActiveLayer(layers[layers.length-1].id);
        }
        function updateLayerOpacity(val) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; l.opacity = val / 100; l.canvas.style.opacity = l.opacity; document.getElementById('layer-op-val').innerText = val; }
        function updateLayerBlendMode(mode) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; l.blendMode = mode; l.canvas.style.mixBlendMode = mode; renderLayers(); }
        function toggleAlphaLock(checked) { const l = layers.find(x => x.id === activeLayerId); if(!l) return; l.alphaLock = checked; renderLayers(); }

        // --- MANGA TEMPLATES ---
        function applyTemplate(type) { /* ...Same... */ 
            const l = addLayer('Template ' + type); const ctx = l.ctx; const w = config.width; const h = config.height; const pad = 40; ctx.strokeStyle = '#000000'; ctx.lineWidth = 3;
            if (type === '4koma') { const panelH = (h - (pad * 5)) / 4; for(let i=0; i<4; i++) ctx.strokeRect(pad * 4, pad + (i * (panelH + pad)), w - (pad * 8), panelH); } 
            else if (type === 'standard') { ctx.strokeRect(pad, pad, w - (pad*2), h * 0.4); ctx.strokeRect(pad, h*0.4 + pad*2, (w/2) - pad*1.5, h * 0.45); ctx.strokeRect(w/2 + pad/2, h*0.4 + pad*2, (w/2) - pad*1.5, h * 0.45); } 
            else if (type === 'action') { ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(w*0.6, pad); ctx.lineTo(w*0.4, h-pad); ctx.lineTo(pad, h-pad); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(w*0.6 + pad, pad); ctx.lineTo(w-pad, pad); ctx.lineTo(w-pad, h-pad); ctx.lineTo(w*0.4 + pad, h-pad); ctx.closePath(); ctx.stroke(); } 
            else if (type === 'dialog') { const rowH = (h - (pad*4)) / 3; ctx.strokeRect(pad, pad, w-pad*2, rowH); ctx.strokeRect(pad, pad*2 + rowH, w-pad*2, rowH); ctx.strokeRect(pad, pad*3 + rowH*2, w-pad*2, rowH); }
            saveHistory(l);
        }

        // --- FILTERS ---
        function applyFilter(type) {
            const l = layers.find(x => x.id === activeLayerId); if(!l) return;
            const ctx = l.ctx; const w = config.width; const h = config.height;
            saveHistory(l);
            ctx.save();
            if (type === 'blur') {
                const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h; const tCtx = tmp.getContext('2d');
                tCtx.filter = 'blur(5px)'; tCtx.drawImage(l.canvas, 0, 0);
                ctx.clearRect(0, 0, w, h); ctx.drawImage(tmp, 0, 0);
            } else {
                const imgData = ctx.getImageData(0, 0, w, h); const d = imgData.data;
                for (let i = 0; i < d.length; i += 4) {
                    if (d[i+3] === 0) continue; 
                    if (type === 'grayscale') { const avg = (d[i] + d[i+1] + d[i+2]) / 3; d[i] = avg; d[i+1] = avg; d[i+2] = avg; } 
                    else if (type === 'invert') { d[i] = 255 - d[i]; d[i+1] = 255 - d[i+1]; d[i+2] = 255 - d[i+2]; } 
                    else if (type === 'brightness') { d[i] += 40; d[i+1] += 40; d[i+2] += 40; }
                }
                ctx.putImageData(imgData, 0, 0);
            }
            ctx.restore();
        }

        // --- INTERACTION ENGINE ---
        const wrapper = document.getElementById('canvas-wrapper');
        const viewport = document.getElementById('viewport');
        const selectionBox = document.getElementById('selection-box');
        
        viewport.addEventListener('pointerdown', onMouseDown);
        window.addEventListener('pointermove', onMouseMove);
        window.addEventListener('pointerup', onMouseUp);
        window.addEventListener('pointercancel', onMouseUp);

        function getActiveCtx() { const l = layers.find(x => x.id === activeLayerId); return (l && l.visible) ? l.ctx : null; }

        function onMouseDown(e) {
            if (e.isPrimary === false) return; 
            
            if (tools.current === 'hand') {
                isPanning = true; startPanX = e.clientX; startPanY = e.clientY;
                viewport.classList.add('panning'); viewport.setPointerCapture(e.pointerId); return;
            }

            const rect = wrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left) / config.zoom;
            const y = (e.clientY - rect.top) / config.zoom;
            lastX = x; lastY = y; 

            if (x < 0 || y < 0 || x > config.width || y > config.height) return;
            if (tools.current === 'eyedropper' || isAltDown) { pickColor(x, y); return; }

            const ctx = getActiveCtx(); if (!ctx) return;
            const l = layers.find(x => x.id === activeLayerId);
            viewport.setPointerCapture(e.pointerId);

            if (tools.current === 'move') { isDrawing = true; moveStart = { x, y }; moveSnapshot = ctx.getImageData(0,0, config.width, config.height); return; }
            if (tools.current === 'select') { isSelecting = true; selStart = { x, y }; selectionBox.style.display = 'block'; selectionBox.style.left = x + 'px'; selectionBox.style.top = y + 'px'; selectionBox.style.width = '0px'; selectionBox.style.height = '0px'; return; }

            isDrawing = true; ctx.save();
            if (selection) { ctx.beginPath(); ctx.rect(selection.x, selection.y, selection.w, selection.h); ctx.clip(); }

            if (l.alphaLock && tools.current !== 'eraser') { ctx.globalCompositeOperation = 'source-atop'; } 
            else if (tools.current === 'eraser') { ctx.globalCompositeOperation = 'destination-out'; } 
            else { ctx.globalCompositeOperation = 'source-over'; }

            const pressure = e.pressure !== 0 ? e.pressure : 0.5;
            points = []; points.push({ x, y, pressure });

            if (tools.current === 'fill') {
                if(!l.alphaLock) ctx.globalCompositeOperation = 'source-over'; 
                floodFill(ctx, Math.floor(x), Math.floor(y), tools.color); 
                isDrawing = false; ctx.restore(); return;
            }

            // STYLE LOGIC
            ctx.lineCap = (tools.brushType === 'square') ? 'square' : 'round';
            ctx.lineJoin = (tools.brushType === 'square') ? 'bevel' : 'round';
            ctx.strokeStyle = tools.color; ctx.fillStyle = tools.color;
            ctx.globalAlpha = tools.current === 'eraser' ? 1 : tools.opacity;
            
            // --- UPDATED: SOFT ERASER / BRUSH LOGIC ---
            if (tools.current === 'eraser') {
                 if (tools.eraserType === 'soft') {
                     ctx.shadowBlur = tools.size; // Strong blur for soft eraser
                     ctx.shadowColor = 'rgba(0,0,0,1)'; // Shadow allows clearing in dest-out mode
                 } else {
                     ctx.shadowBlur = 0;
                 }
            } else if (tools.brushType === 'soft') {
                ctx.shadowBlur = tools.size / 2;
                ctx.shadowColor = tools.color;
            } else {
                ctx.shadowBlur = 0;
            }

            if (['rect', 'circle', 'triangle'].includes(tools.current)) {
                snapshot = ctx.getImageData(0,0, config.width, config.height); ctx.beginPath();
            }
        }

        function onMouseMove(e) {
            if (isPanning) {
                config.panX += e.clientX - startPanX; config.panY += e.clientY - startPanY;
                startPanX = e.clientX; startPanY = e.clientY; updateCanvasTransform(); return;
            }

            const rect = wrapper.getBoundingClientRect();
            let rawX = (e.clientX - rect.left) / config.zoom;
            let rawY = (e.clientY - rect.top) / config.zoom;

            if (isSelecting) {
                const w = rawX - selStart.x; const h = rawY - selStart.y;
                selectionBox.style.left = (w < 0 ? rawX : selStart.x) + 'px'; selectionBox.style.top = (h < 0 ? rawY : selStart.y) + 'px';
                selectionBox.style.width = Math.abs(w) + 'px'; selectionBox.style.height = Math.abs(h) + 'px'; return;
            }

            if ((tools.current === 'eyedropper' || isAltDown) && e.buttons === 1) { pickColor(rawX, rawY); return; }

            if (!isDrawing) return;
            const ctx = getActiveCtx();

            if (tools.current === 'move' && moveSnapshot) {
                const dx = rawX - moveStart.x; const dy = rawY - moveStart.y;
                ctx.clearRect(0,0, config.width, config.height); ctx.putImageData(moveSnapshot, dx, dy); return;
            }

            if (['rect', 'circle', 'triangle'].includes(tools.current)) {
                ctx.putImageData(snapshot, 0, 0); drawShape(ctx, points[0].x, points[0].y, rawX, rawY); return;
            }

            // STABILIZER
            let x = rawX; let y = rawY;
            if (tools.stabilizer > 0) {
                const factor = 1 - (tools.stabilizer * 0.08); 
                x = lastX + (rawX - lastX) * factor; y = lastY + (rawY - lastY) * factor;
                lastX = x; lastY = y;
            } else { lastX = rawX; lastY = rawY; }

            const usePressure = document.getElementById('pressure-chk').checked;
            const pressure = (usePressure && e.pointerType === 'pen') ? e.pressure : 0.5;
            points.push({ x, y, pressure });

            if (points.length < 3) {
                const b = points[0]; ctx.beginPath();
                const dotSize = tools.size * (usePressure ? (b.pressure * 2) : 1);
                ctx.arc(b.x, b.y, dotSize / 2, 0, Math.PI * 2, !0); ctx.fill(); ctx.closePath(); return;
            }

            const p0 = points[points.length - 3]; const p1 = points[points.length - 2]; const p2 = points[points.length - 1];
            const cp = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 }; const cp2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            
            ctx.beginPath(); ctx.moveTo(cp.x, cp.y); ctx.quadraticCurveTo(p1.x, p1.y, cp2.x, cp2.y);
            const dynamicSize = tools.size * (usePressure ? (p1.pressure * 2) : 1);
            ctx.lineWidth = dynamicSize; ctx.stroke();
        }

        function onMouseUp(e) {
            if (isPanning) { isPanning = false; viewport.classList.remove('panning'); viewport.releasePointerCapture(e.pointerId); return; }
            if (isSelecting) {
                isSelecting = false; const sb = selectionBox.style;
                selection = { x: parseFloat(sb.left), y: parseFloat(sb.top), w: parseFloat(sb.width), h: parseFloat(sb.height) };
                if(selection.w < 2 || selection.h < 2) { selection = null; selectionBox.style.display = 'none'; }
                viewport.releasePointerCapture(e.pointerId); return;
            }

            if (isDrawing) {
                isDrawing = false; viewport.releasePointerCapture(e.pointerId); points = [];
                const ctx = getActiveCtx();
                if(ctx) {
                    ctx.shadowBlur = 0; 
                    ctx.restore(); 
                    ctx.globalCompositeOperation = 'source-over';
                }
                saveHistory(layers.find(x => x.id === activeLayerId));
            }
        }

        // --- HELPERS ---
        function pickColor(x, y) { /* ...Same... */ 
            const tmp = document.createElement('canvas'); tmp.width = 1; tmp.height = 1; const tCtx = tmp.getContext('2d');
            tCtx.fillStyle = '#ffffff'; tCtx.fillRect(0,0,1,1);
            layers.forEach(l => { if (l.visible) { tCtx.globalAlpha = l.opacity; tCtx.globalCompositeOperation = (l.blendMode === 'normal') ? 'source-over' : l.blendMode; tCtx.drawImage(l.canvas, x, y, 1, 1, 0, 0, 1, 1); } });
            const p = tCtx.getImageData(0,0,1,1).data; const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
            syncSettings('color', hex);
        }
        function drawShape(ctx, x1, y1, x2, y2) { /* ...Same... */ 
             ctx.beginPath(); ctx.lineWidth = tools.size; const w = x2 - x1; const h = y2 - y1; const fill = document.getElementById('fill-shape-chk').checked;
            if (tools.current === 'rect') { fill ? ctx.fillRect(x1, y1, w, h) : ctx.strokeRect(x1, y1, w, h); } else if (tools.current === 'circle') { ctx.ellipse(x1 + w/2, y1 + h/2, Math.abs(w/2), Math.abs(h/2), 0, 0, 2 * Math.PI); fill ? ctx.fill() : ctx.stroke(); } else if (tools.current === 'triangle') { ctx.moveTo(x1 + w / 2, y1); ctx.lineTo(x1, y1 + h); ctx.lineTo(x1 + w, y1 + h); ctx.closePath(); fill ? ctx.fill() : ctx.stroke(); }
        }
        function floodFill(ctx, x, y, hexColor) { /* ...Same... */ 
             const r = parseInt(hexColor.slice(1,3), 16); const g = parseInt(hexColor.slice(3,5), 16); const b = parseInt(hexColor.slice(5,7), 16); const imgData = ctx.getImageData(0,0, config.width, config.height); const data = imgData.data; const pos = (y * config.width + x) * 4; const sr = data[pos], sg = data[pos+1], sb = data[pos+2], sa = data[pos+3]; if (sr===r && sg===g && sb===b && sa===255) return; const stack = [[x,y]]; while(stack.length) { const [cx, cy] = stack.pop(); const idx = (cy * config.width + cx) * 4; if (cx>=0 && cx<config.width && cy>=0 && cy<config.height) { if (data[idx]===sr && data[idx+1]===sg && data[idx+2]===sb && data[idx+3]===sa) { data[idx]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=255; stack.push([cx+1, cy]); stack.push([cx-1, cy]); stack.push([cx, cy+1]); stack.push([cx, cy-1]); } } } ctx.putImageData(imgData, 0, 0); saveHistory(layers.find(x => x.id === activeLayerId));
        }

        function saveHistory(layer) { layer.historyPtr++; if (layer.historyPtr < layer.history.length) layer.history.length = layer.historyPtr; if (layer.history.length > 20) { layer.history.shift(); layer.historyPtr--; } layer.history.push(layer.canvas.toDataURL()); }
        function layerUndo() { const l = layers.find(x => x.id === activeLayerId); if (!l || l.historyPtr <= 0) return; l.historyPtr--; const img = new Image(); img.src = l.history[l.historyPtr]; img.onload = () => { l.ctx.clearRect(0,0, config.width, config.height); l.ctx.drawImage(img, 0, 0); }; }
        function triggerUpload() { document.getElementById('upload-input').click(); }
        function processUpload(input) { if(input.files && input.files[0]) { const reader = new FileReader(); reader.onload = (e) => { const img = new Image(); img.onload = () => { const l = addLayer('Imported Image'); const aspect = img.width / img.height; let drawW = img.width; let drawH = img.height; if (drawW > config.width) { drawW = config.width; drawH = drawW / aspect; } if (drawH > config.height) { drawH = config.height; drawW = drawH * aspect; } const x = (config.width - drawW) / 2; const y = (config.height - drawH) / 2; l.ctx.drawImage(img, x, y, drawW, drawH); saveHistory(l); }; img.src = e.target.result; }; reader.readAsDataURL(input.files[0]); } input.value = ''; }
        function exportImage() { const tmp = document.createElement('canvas'); tmp.width = config.width; tmp.height = config.height; const tCtx = tmp.getContext('2d'); layers.forEach(l => { if(l.visible) { tCtx.globalAlpha = l.opacity; tCtx.globalCompositeOperation = (l.blendMode === 'normal') ? 'source-over' : l.blendMode; tCtx.drawImage(l.canvas, 0, 0); } }); const link = document.createElement('a'); link.download = 'fercy-studio-export.png'; link.href = tmp.toDataURL(); link.click(); }
        function toggleTheme() { const b = document.body; b.setAttribute('data-theme', b.getAttribute('data-theme')==='light'?'dark':'light'); }
    </script>
</body>
</html>

